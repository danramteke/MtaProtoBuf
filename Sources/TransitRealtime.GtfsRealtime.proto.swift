/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "gtfs-realtime.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public struct TransitRealtime { }

public extension TransitRealtime {
    public struct GtfsRealtimeRoot {
        public static let `default` = GtfsRealtimeRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    /// The contents of a feed message.
    /// A feed is a continuous stream of feed messages. Each message in the stream is
    /// obtained as a response to an appropriate HTTP GET request.
    /// A realtime feed is always defined with relation to an existing GTFS feed.
    /// All the entity ids are resolved with respect to the GTFS feed.
    /// A feed depends on some external configuration:
    /// - The corresponding GTFS feed.
    /// - Feed application (updates, positions or alerts). A feed should contain only
    ///   items of one specified application; all the other entities will be ignored.
    /// - Polling frequency
    final public class FeedMessage : ExtendableMessage {

        public static func == (lhs: TransitRealtime.FeedMessage, rhs: TransitRealtime.FeedMessage) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasHeader == rhs.hasHeader) && (!lhs.hasHeader || lhs.header == rhs.header)
            fieldCheck = fieldCheck && (lhs.entity == rhs.entity)
            fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:2000)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var header:TransitRealtime.FeedHeader!
        public fileprivate(set) var hasHeader:Bool = false
        public fileprivate(set) var entity:Array<TransitRealtime.FeedEntity>  = Array<TransitRealtime.FeedEntity>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasHeader {
                return false
            }
            if !header.isInitialized() {
                return false
            }
            var isInitEntity:Bool = true
            for oneElementEntity in entity {
                if !oneElementEntity.isInitialized() {
                    isInitEntity = false
                    break 
                }
            }
            if !isInitEntity {
                return isInitEntity
            }
            if !extensionsAreInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasHeader {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:header)
            }
            for oneElementEntity in entity {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementEntity)
            }
            try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:2000)
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasHeader {
                if let varSizeheader = header?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeheader
                }
            }
            for oneElementEntity in entity {
                serialize_size += oneElementEntity.computeMessageSize(fieldNumber: 2)
            }
            serialize_size += extensionsSerializedSize()
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> TransitRealtime.FeedMessage.Builder {
            return TransitRealtime.FeedMessage.classBuilder() as! TransitRealtime.FeedMessage.Builder
        }
        public func getBuilder() -> TransitRealtime.FeedMessage.Builder {
            return classBuilder() as! TransitRealtime.FeedMessage.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.FeedMessage.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.FeedMessage.Builder()
        }
        public func toBuilder() throws -> TransitRealtime.FeedMessage.Builder {
            return try TransitRealtime.FeedMessage.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:TransitRealtime.FeedMessage) throws -> TransitRealtime.FeedMessage.Builder {
            return try TransitRealtime.FeedMessage.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasHeader {
                jsonMap["header"] = try header.encode()
            }
            if !entity.isEmpty {
                var jsonArrayEntity:Array<Dictionary<String,Any>> = []
                for oneValueEntity in entity {
                    let ecodedMessageEntity = try oneValueEntity.encode()
                    jsonArrayEntity.append(ecodedMessageEntity)
                }
                jsonMap["entity"] = jsonArrayEntity
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.FeedMessage {
            return try TransitRealtime.FeedMessage.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> TransitRealtime.FeedMessage {
            return try TransitRealtime.FeedMessage.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasHeader {
                output += "\(indent) header {\n"
                if let outDescHeader = header {
                    output += try outDescHeader.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var entityElementIndex:Int = 0
            for oneElementEntity in entity {
                output += "\(indent) entity[\(entityElementIndex)] {\n"
                output += try oneElementEntity.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                entityElementIndex += 1
            }
            output += try getExtensionDescription(startInclusive:1000, endExclusive:2000, indent:indent)
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasHeader {
                    if let hashValueheader = header?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueheader
                    }
                }
                for oneElementEntity in entity {
                    hashCode = (hashCode &* 31) &+ oneElementEntity.hashValue
                }
                hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:2000))
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "TransitRealtime.FeedMessage"
        }
        override public func className() -> String {
            return "TransitRealtime.FeedMessage"
        }
        //Meta information declaration end

        final public class Builder : ExtendableMessageBuilder {
            fileprivate var builderResult:TransitRealtime.FeedMessage = TransitRealtime.FeedMessage()
            public func getMessage() -> TransitRealtime.FeedMessage {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Metadata about this feed and feed message.
            public var header:TransitRealtime.FeedHeader! {
                get {
                    if headerBuilder_ != nil {
                        builderResult.header = headerBuilder_.getMessage()
                    }
                    return builderResult.header
                }
                set (value) {
                    builderResult.hasHeader = true
                    builderResult.header = value
                }
            }
            public var hasHeader:Bool {
                get {
                    return builderResult.hasHeader
                }
            }
            fileprivate var headerBuilder_:TransitRealtime.FeedHeader.Builder! {
                didSet {
                    builderResult.hasHeader = true
                }
            }
            public func getHeaderBuilder() -> TransitRealtime.FeedHeader.Builder {
                if headerBuilder_ == nil {
                    headerBuilder_ = TransitRealtime.FeedHeader.Builder()
                    builderResult.header = headerBuilder_.getMessage()
                    if header != nil {
                        try! headerBuilder_.mergeFrom(other: header)
                    }
                }
                return headerBuilder_
            }
            @discardableResult
            public func setHeader(_ value:TransitRealtime.FeedHeader!) -> TransitRealtime.FeedMessage.Builder {
                self.header = value
                return self
            }
            @discardableResult
            public func mergeHeader(value:TransitRealtime.FeedHeader) throws -> TransitRealtime.FeedMessage.Builder {
                if builderResult.hasHeader {
                    builderResult.header = try TransitRealtime.FeedHeader.builderWithPrototype(prototype:builderResult.header).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.header = value
                }
                builderResult.hasHeader = true
                return self
            }
            @discardableResult
            public func clearHeader() -> TransitRealtime.FeedMessage.Builder {
                headerBuilder_ = nil
                builderResult.hasHeader = false
                builderResult.header = nil
                return self
            }
            /// Contents of the feed.
            public var entity:Array<TransitRealtime.FeedEntity> {
                get {
                    return builderResult.entity
                }
                set (value) {
                    builderResult.entity = value
                }
            }
            @discardableResult
            public func setEntity(_ value:Array<TransitRealtime.FeedEntity>) -> TransitRealtime.FeedMessage.Builder {
                self.entity = value
                return self
            }
            @discardableResult
            public func clearEntity() -> TransitRealtime.FeedMessage.Builder {
                builderResult.entity.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:ExtendableMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> TransitRealtime.FeedMessage.Builder {
                builderResult = TransitRealtime.FeedMessage()
                return self
            }
            override public func clone() throws -> TransitRealtime.FeedMessage.Builder {
                return try TransitRealtime.FeedMessage.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> TransitRealtime.FeedMessage {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> TransitRealtime.FeedMessage {
                let returnMe:TransitRealtime.FeedMessage = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:TransitRealtime.FeedMessage) throws -> TransitRealtime.FeedMessage.Builder {
                if other == TransitRealtime.FeedMessage() {
                    return self
                }
                if (other.hasHeader) {
                    try mergeHeader(value: other.header)
                }
                if !other.entity.isEmpty  {
                     builderResult.entity += other.entity
                }
                try mergeExtensionFields(other: other)
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.FeedMessage.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedMessage.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:TransitRealtime.FeedHeader.Builder = TransitRealtime.FeedHeader.Builder()
                        if hasHeader {
                            try subBuilder.mergeFrom(other: header)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        header = subBuilder.buildPartial()

                    case 18:
                        let subBuilder = TransitRealtime.FeedEntity.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        entity.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.FeedMessage.Builder {
                let resultDecodedBuilder = TransitRealtime.FeedMessage.Builder()
                if let jsonValueHeader = jsonMap["header"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.header = try TransitRealtime.FeedHeader.Builder.decodeToBuilder(jsonMap:jsonValueHeader).build()

                }
                if let jsonValueEntity = jsonMap["entity"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayEntity:Array<TransitRealtime.FeedEntity> = []
                    for oneValueEntity in jsonValueEntity {
                        let messageFromStringEntity = try TransitRealtime.FeedEntity.Builder.decodeToBuilder(jsonMap:oneValueEntity).build()

                        jsonArrayEntity.append(messageFromStringEntity)
                    }
                    resultDecodedBuilder.entity = jsonArrayEntity
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> TransitRealtime.FeedMessage.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try TransitRealtime.FeedMessage.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Metadata about a feed, included in feed messages.
    final public class FeedHeader : ExtendableMessage {

        public static func == (lhs: TransitRealtime.FeedHeader, rhs: TransitRealtime.FeedHeader) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGtfsRealtimeVersion == rhs.hasGtfsRealtimeVersion) && (!lhs.hasGtfsRealtimeVersion || lhs.gtfsRealtimeVersion == rhs.gtfsRealtimeVersion)
            fieldCheck = fieldCheck && (lhs.hasIncrementality == rhs.hasIncrementality) && (!lhs.hasIncrementality || lhs.incrementality == rhs.incrementality)
            fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
            fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:2000)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



            //Enum type declaration start 

            /// Determines whether the current fetch is incremental.  Currently,
            /// DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds
            /// that use this mode.  There are discussions on the GTFS-realtime mailing
            /// list around fully specifying the behavior of DIFFERENTIAL mode and the
            /// documentation will be updated when those discussions are finalized.
            public enum Incrementality:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                case fullDataset = 0
                case differential = 1
                public func toString() -> String {
                    switch self {
                    case .fullDataset: return "FULL_DATASET"
                    case .differential: return "DIFFERENTIAL"
                    }
                }
                public static func fromString(str:String) throws -> TransitRealtime.FeedHeader.Incrementality {
                    switch str {
                    case "FULL_DATASET":    return .fullDataset
                    case "DIFFERENTIAL":    return .differential
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .fullDataset: return ".fullDataset"
                    case .differential: return ".differential"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:Incrementality, rhs:Incrementality) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        /// Version of the feed specification.
        /// The current version is 1.0.
        public fileprivate(set) var gtfsRealtimeVersion:String = ""
        public fileprivate(set) var hasGtfsRealtimeVersion:Bool = false

        public fileprivate(set) var incrementality:TransitRealtime.FeedHeader.Incrementality = TransitRealtime.FeedHeader.Incrementality.fullDataset
        public fileprivate(set) var hasIncrementality:Bool = false
        /// This timestamp identifies the moment when the content of this feed has been
        /// created (in server time). In POSIX time (i.e., number of seconds since
        /// January 1st 1970 00:00:00 UTC).
        public fileprivate(set) var timestamp:UInt64 = UInt64(0)
        public fileprivate(set) var hasTimestamp:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGtfsRealtimeVersion {
                return false
            }
            if !extensionsAreInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGtfsRealtimeVersion {
                try codedOutputStream.writeString(fieldNumber: 1, value:gtfsRealtimeVersion)
            }
            if hasIncrementality {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:incrementality.rawValue)
            }
            if hasTimestamp {
                try codedOutputStream.writeUInt64(fieldNumber: 3, value:timestamp)
            }
            try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:2000)
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGtfsRealtimeVersion {
                serialize_size += gtfsRealtimeVersion.computeStringSize(fieldNumber: 1)
            }
            if (hasIncrementality) {
                serialize_size += incrementality.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasTimestamp {
                serialize_size += timestamp.computeUInt64Size(fieldNumber: 3)
            }
            serialize_size += extensionsSerializedSize()
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> TransitRealtime.FeedHeader.Builder {
            return TransitRealtime.FeedHeader.classBuilder() as! TransitRealtime.FeedHeader.Builder
        }
        public func getBuilder() -> TransitRealtime.FeedHeader.Builder {
            return classBuilder() as! TransitRealtime.FeedHeader.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.FeedHeader.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.FeedHeader.Builder()
        }
        public func toBuilder() throws -> TransitRealtime.FeedHeader.Builder {
            return try TransitRealtime.FeedHeader.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:TransitRealtime.FeedHeader) throws -> TransitRealtime.FeedHeader.Builder {
            return try TransitRealtime.FeedHeader.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGtfsRealtimeVersion {
                jsonMap["gtfsRealtimeVersion"] = gtfsRealtimeVersion
            }
            if hasIncrementality {
                jsonMap["incrementality"] = incrementality.toString()
            }
            if hasTimestamp {
                jsonMap["timestamp"] = "\(timestamp)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.FeedHeader {
            return try TransitRealtime.FeedHeader.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> TransitRealtime.FeedHeader {
            return try TransitRealtime.FeedHeader.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGtfsRealtimeVersion {
                output += "\(indent) gtfsRealtimeVersion: \(gtfsRealtimeVersion) \n"
            }
            if (hasIncrementality) {
                output += "\(indent) incrementality: \(incrementality.description)\n"
            }
            if hasTimestamp {
                output += "\(indent) timestamp: \(timestamp) \n"
            }
            output += try getExtensionDescription(startInclusive:1000, endExclusive:2000, indent:indent)
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGtfsRealtimeVersion {
                    hashCode = (hashCode &* 31) &+ gtfsRealtimeVersion.hashValue
                }
                if hasIncrementality {
                     hashCode = (hashCode &* 31) &+ incrementality.hashValue
                }
                if hasTimestamp {
                    hashCode = (hashCode &* 31) &+ timestamp.hashValue
                }
                hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:2000))
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "TransitRealtime.FeedHeader"
        }
        override public func className() -> String {
            return "TransitRealtime.FeedHeader"
        }
        //Meta information declaration end

        final public class Builder : ExtendableMessageBuilder {
            fileprivate var builderResult:TransitRealtime.FeedHeader = TransitRealtime.FeedHeader()
            public func getMessage() -> TransitRealtime.FeedHeader {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Version of the feed specification.
            /// The current version is 1.0.
            public var gtfsRealtimeVersion:String {
                get {
                    return builderResult.gtfsRealtimeVersion
                }
                set (value) {
                    builderResult.hasGtfsRealtimeVersion = true
                    builderResult.gtfsRealtimeVersion = value
                }
            }
            public var hasGtfsRealtimeVersion:Bool {
                get {
                    return builderResult.hasGtfsRealtimeVersion
                }
            }
            @discardableResult
            public func setGtfsRealtimeVersion(_ value:String) -> TransitRealtime.FeedHeader.Builder {
                self.gtfsRealtimeVersion = value
                return self
            }
            @discardableResult
            public func clearGtfsRealtimeVersion() -> TransitRealtime.FeedHeader.Builder{
                builderResult.hasGtfsRealtimeVersion = false
                builderResult.gtfsRealtimeVersion = ""
                return self
            }
                public var incrementality:TransitRealtime.FeedHeader.Incrementality {
                    get {
                        return builderResult.incrementality
                    }
                    set (value) {
                        builderResult.hasIncrementality = true
                        builderResult.incrementality = value
                    }
                }
                public var hasIncrementality:Bool{
                    get {
                        return builderResult.hasIncrementality
                    }
                }
            @discardableResult
                public func setIncrementality(_ value:TransitRealtime.FeedHeader.Incrementality) -> TransitRealtime.FeedHeader.Builder {
                  self.incrementality = value
                  return self
                }
            @discardableResult
                public func clearIncrementality() -> TransitRealtime.FeedHeader.Builder {
                   builderResult.hasIncrementality = false
                   builderResult.incrementality = .fullDataset
                   return self
                }
            /// This timestamp identifies the moment when the content of this feed has been
            /// created (in server time). In POSIX time (i.e., number of seconds since
            /// January 1st 1970 00:00:00 UTC).
            public var timestamp:UInt64 {
                get {
                    return builderResult.timestamp
                }
                set (value) {
                    builderResult.hasTimestamp = true
                    builderResult.timestamp = value
                }
            }
            public var hasTimestamp:Bool {
                get {
                    return builderResult.hasTimestamp
                }
            }
            @discardableResult
            public func setTimestamp(_ value:UInt64) -> TransitRealtime.FeedHeader.Builder {
                self.timestamp = value
                return self
            }
            @discardableResult
            public func clearTimestamp() -> TransitRealtime.FeedHeader.Builder{
                builderResult.hasTimestamp = false
                builderResult.timestamp = UInt64(0)
                return self
            }
            override public var internalGetResult:ExtendableMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> TransitRealtime.FeedHeader.Builder {
                builderResult = TransitRealtime.FeedHeader()
                return self
            }
            override public func clone() throws -> TransitRealtime.FeedHeader.Builder {
                return try TransitRealtime.FeedHeader.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> TransitRealtime.FeedHeader {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> TransitRealtime.FeedHeader {
                let returnMe:TransitRealtime.FeedHeader = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:TransitRealtime.FeedHeader) throws -> TransitRealtime.FeedHeader.Builder {
                if other == TransitRealtime.FeedHeader() {
                    return self
                }
                if other.hasGtfsRealtimeVersion {
                    gtfsRealtimeVersion = other.gtfsRealtimeVersion
                }
                if other.hasIncrementality {
                    incrementality = other.incrementality
                }
                if other.hasTimestamp {
                    timestamp = other.timestamp
                }
                try mergeExtensionFields(other: other)
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.FeedHeader.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedHeader.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        gtfsRealtimeVersion = try codedInputStream.readString()

                    case 16:
                        let valueIntincrementality = try codedInputStream.readEnum()
                        if let enumsincrementality = TransitRealtime.FeedHeader.Incrementality(rawValue:valueIntincrementality){
                            incrementality = enumsincrementality
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntincrementality))
                        }

                    case 24:
                        timestamp = try codedInputStream.readUInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.FeedHeader.Builder {
                let resultDecodedBuilder = TransitRealtime.FeedHeader.Builder()
                if let jsonValueGtfsRealtimeVersion = jsonMap["gtfsRealtimeVersion"] as? String {
                    resultDecodedBuilder.gtfsRealtimeVersion = jsonValueGtfsRealtimeVersion
                }
                if let jsonValueIncrementality = jsonMap["incrementality"] as? String {
                    resultDecodedBuilder.incrementality = try TransitRealtime.FeedHeader.Incrementality.fromString(str: jsonValueIncrementality)
                }
                if let jsonValueTimestamp = jsonMap["timestamp"] as? String {
                    resultDecodedBuilder.timestamp = UInt64(jsonValueTimestamp)!
                } else if let jsonValueTimestamp = jsonMap["timestamp"] as? UInt {
                    resultDecodedBuilder.timestamp = UInt64(jsonValueTimestamp)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> TransitRealtime.FeedHeader.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try TransitRealtime.FeedHeader.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// A definition (or update) of an entity in the transit feed.
    final public class FeedEntity : ExtendableMessage {

        public static func == (lhs: TransitRealtime.FeedEntity, rhs: TransitRealtime.FeedEntity) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
            fieldCheck = fieldCheck && (lhs.hasIsDeleted == rhs.hasIsDeleted) && (!lhs.hasIsDeleted || lhs.isDeleted == rhs.isDeleted)
            fieldCheck = fieldCheck && (lhs.hasTripUpdate == rhs.hasTripUpdate) && (!lhs.hasTripUpdate || lhs.tripUpdate == rhs.tripUpdate)
            fieldCheck = fieldCheck && (lhs.hasVehicle == rhs.hasVehicle) && (!lhs.hasVehicle || lhs.vehicle == rhs.vehicle)
            fieldCheck = fieldCheck && (lhs.hasAlert == rhs.hasAlert) && (!lhs.hasAlert || lhs.alert == rhs.alert)
            fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:2000)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The ids are used only to provide incrementality support. The id should be
        /// unique within a FeedMessage. Consequent FeedMessages may contain
        /// FeedEntities with the same id. In case of a DIFFERENTIAL update the new
        /// FeedEntity with some id will replace the old FeedEntity with the same id
        /// (or delete it - see is_deleted below).
        /// The actual GTFS entities (e.g. stations, routes, trips) referenced by the
        /// feed must be specified by explicit selectors (see EntitySelector below for
        /// more info).
        public fileprivate(set) var id:String = ""
        public fileprivate(set) var hasId:Bool = false

        /// Whether this entity is to be deleted. Relevant only for incremental
        /// fetches.
        public fileprivate(set) var isDeleted:Bool = false
        public fileprivate(set) var hasIsDeleted:Bool = false

        public fileprivate(set) var tripUpdate:TransitRealtime.TripUpdate!
        public fileprivate(set) var hasTripUpdate:Bool = false
        public fileprivate(set) var vehicle:TransitRealtime.VehiclePosition!
        public fileprivate(set) var hasVehicle:Bool = false
        public fileprivate(set) var alert:TransitRealtime.Alert!
        public fileprivate(set) var hasAlert:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasId {
                return false
            }
            if hasTripUpdate {
                if !tripUpdate.isInitialized() {
                    return false
                }
            }
            if hasVehicle {
                if !vehicle.isInitialized() {
                    return false
                }
            }
            if hasAlert {
                if !alert.isInitialized() {
                    return false
                }
            }
            if !extensionsAreInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasId {
                try codedOutputStream.writeString(fieldNumber: 1, value:id)
            }
            if hasIsDeleted {
                try codedOutputStream.writeBool(fieldNumber: 2, value:isDeleted)
            }
            if hasTripUpdate {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:tripUpdate)
            }
            if hasVehicle {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:vehicle)
            }
            if hasAlert {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:alert)
            }
            try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:2000)
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasId {
                serialize_size += id.computeStringSize(fieldNumber: 1)
            }
            if hasIsDeleted {
                serialize_size += isDeleted.computeBoolSize(fieldNumber: 2)
            }
            if hasTripUpdate {
                if let varSizetripUpdate = tripUpdate?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizetripUpdate
                }
            }
            if hasVehicle {
                if let varSizevehicle = vehicle?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizevehicle
                }
            }
            if hasAlert {
                if let varSizealert = alert?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizealert
                }
            }
            serialize_size += extensionsSerializedSize()
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> TransitRealtime.FeedEntity.Builder {
            return TransitRealtime.FeedEntity.classBuilder() as! TransitRealtime.FeedEntity.Builder
        }
        public func getBuilder() -> TransitRealtime.FeedEntity.Builder {
            return classBuilder() as! TransitRealtime.FeedEntity.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.FeedEntity.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.FeedEntity.Builder()
        }
        public func toBuilder() throws -> TransitRealtime.FeedEntity.Builder {
            return try TransitRealtime.FeedEntity.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:TransitRealtime.FeedEntity) throws -> TransitRealtime.FeedEntity.Builder {
            return try TransitRealtime.FeedEntity.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasId {
                jsonMap["id"] = id
            }
            if hasIsDeleted {
                jsonMap["isDeleted"] = isDeleted
            }
            if hasTripUpdate {
                jsonMap["tripUpdate"] = try tripUpdate.encode()
            }
            if hasVehicle {
                jsonMap["vehicle"] = try vehicle.encode()
            }
            if hasAlert {
                jsonMap["alert"] = try alert.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.FeedEntity {
            return try TransitRealtime.FeedEntity.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> TransitRealtime.FeedEntity {
            return try TransitRealtime.FeedEntity.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasId {
                output += "\(indent) id: \(id) \n"
            }
            if hasIsDeleted {
                output += "\(indent) isDeleted: \(isDeleted) \n"
            }
            if hasTripUpdate {
                output += "\(indent) tripUpdate {\n"
                if let outDescTripUpdate = tripUpdate {
                    output += try outDescTripUpdate.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasVehicle {
                output += "\(indent) vehicle {\n"
                if let outDescVehicle = vehicle {
                    output += try outDescVehicle.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasAlert {
                output += "\(indent) alert {\n"
                if let outDescAlert = alert {
                    output += try outDescAlert.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += try getExtensionDescription(startInclusive:1000, endExclusive:2000, indent:indent)
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasId {
                    hashCode = (hashCode &* 31) &+ id.hashValue
                }
                if hasIsDeleted {
                    hashCode = (hashCode &* 31) &+ isDeleted.hashValue
                }
                if hasTripUpdate {
                    if let hashValuetripUpdate = tripUpdate?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetripUpdate
                    }
                }
                if hasVehicle {
                    if let hashValuevehicle = vehicle?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuevehicle
                    }
                }
                if hasAlert {
                    if let hashValuealert = alert?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuealert
                    }
                }
                hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:2000))
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "TransitRealtime.FeedEntity"
        }
        override public func className() -> String {
            return "TransitRealtime.FeedEntity"
        }
        //Meta information declaration end

        final public class Builder : ExtendableMessageBuilder {
            fileprivate var builderResult:TransitRealtime.FeedEntity = TransitRealtime.FeedEntity()
            public func getMessage() -> TransitRealtime.FeedEntity {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The ids are used only to provide incrementality support. The id should be
            /// unique within a FeedMessage. Consequent FeedMessages may contain
            /// FeedEntities with the same id. In case of a DIFFERENTIAL update the new
            /// FeedEntity with some id will replace the old FeedEntity with the same id
            /// (or delete it - see is_deleted below).
            /// The actual GTFS entities (e.g. stations, routes, trips) referenced by the
            /// feed must be specified by explicit selectors (see EntitySelector below for
            /// more info).
            public var id:String {
                get {
                    return builderResult.id
                }
                set (value) {
                    builderResult.hasId = true
                    builderResult.id = value
                }
            }
            public var hasId:Bool {
                get {
                    return builderResult.hasId
                }
            }
            @discardableResult
            public func setId(_ value:String) -> TransitRealtime.FeedEntity.Builder {
                self.id = value
                return self
            }
            @discardableResult
            public func clearId() -> TransitRealtime.FeedEntity.Builder{
                builderResult.hasId = false
                builderResult.id = ""
                return self
            }
            /// Whether this entity is to be deleted. Relevant only for incremental
            /// fetches.
            public var isDeleted:Bool {
                get {
                    return builderResult.isDeleted
                }
                set (value) {
                    builderResult.hasIsDeleted = true
                    builderResult.isDeleted = value
                }
            }
            public var hasIsDeleted:Bool {
                get {
                    return builderResult.hasIsDeleted
                }
            }
            @discardableResult
            public func setIsDeleted(_ value:Bool) -> TransitRealtime.FeedEntity.Builder {
                self.isDeleted = value
                return self
            }
            @discardableResult
            public func clearIsDeleted() -> TransitRealtime.FeedEntity.Builder{
                builderResult.hasIsDeleted = false
                builderResult.isDeleted = false
                return self
            }
            /// Data about the entity itself. Exactly one of the following fields must be
            /// present (unless the entity is being deleted).
            public var tripUpdate:TransitRealtime.TripUpdate! {
                get {
                    if tripUpdateBuilder_ != nil {
                        builderResult.tripUpdate = tripUpdateBuilder_.getMessage()
                    }
                    return builderResult.tripUpdate
                }
                set (value) {
                    builderResult.hasTripUpdate = true
                    builderResult.tripUpdate = value
                }
            }
            public var hasTripUpdate:Bool {
                get {
                    return builderResult.hasTripUpdate
                }
            }
            fileprivate var tripUpdateBuilder_:TransitRealtime.TripUpdate.Builder! {
                didSet {
                    builderResult.hasTripUpdate = true
                }
            }
            public func getTripUpdateBuilder() -> TransitRealtime.TripUpdate.Builder {
                if tripUpdateBuilder_ == nil {
                    tripUpdateBuilder_ = TransitRealtime.TripUpdate.Builder()
                    builderResult.tripUpdate = tripUpdateBuilder_.getMessage()
                    if tripUpdate != nil {
                        try! tripUpdateBuilder_.mergeFrom(other: tripUpdate)
                    }
                }
                return tripUpdateBuilder_
            }
            @discardableResult
            public func setTripUpdate(_ value:TransitRealtime.TripUpdate!) -> TransitRealtime.FeedEntity.Builder {
                self.tripUpdate = value
                return self
            }
            @discardableResult
            public func mergeTripUpdate(value:TransitRealtime.TripUpdate) throws -> TransitRealtime.FeedEntity.Builder {
                if builderResult.hasTripUpdate {
                    builderResult.tripUpdate = try TransitRealtime.TripUpdate.builderWithPrototype(prototype:builderResult.tripUpdate).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.tripUpdate = value
                }
                builderResult.hasTripUpdate = true
                return self
            }
            @discardableResult
            public func clearTripUpdate() -> TransitRealtime.FeedEntity.Builder {
                tripUpdateBuilder_ = nil
                builderResult.hasTripUpdate = false
                builderResult.tripUpdate = nil
                return self
            }
            public var vehicle:TransitRealtime.VehiclePosition! {
                get {
                    if vehicleBuilder_ != nil {
                        builderResult.vehicle = vehicleBuilder_.getMessage()
                    }
                    return builderResult.vehicle
                }
                set (value) {
                    builderResult.hasVehicle = true
                    builderResult.vehicle = value
                }
            }
            public var hasVehicle:Bool {
                get {
                    return builderResult.hasVehicle
                }
            }
            fileprivate var vehicleBuilder_:TransitRealtime.VehiclePosition.Builder! {
                didSet {
                    builderResult.hasVehicle = true
                }
            }
            public func getVehicleBuilder() -> TransitRealtime.VehiclePosition.Builder {
                if vehicleBuilder_ == nil {
                    vehicleBuilder_ = TransitRealtime.VehiclePosition.Builder()
                    builderResult.vehicle = vehicleBuilder_.getMessage()
                    if vehicle != nil {
                        try! vehicleBuilder_.mergeFrom(other: vehicle)
                    }
                }
                return vehicleBuilder_
            }
            @discardableResult
            public func setVehicle(_ value:TransitRealtime.VehiclePosition!) -> TransitRealtime.FeedEntity.Builder {
                self.vehicle = value
                return self
            }
            @discardableResult
            public func mergeVehicle(value:TransitRealtime.VehiclePosition) throws -> TransitRealtime.FeedEntity.Builder {
                if builderResult.hasVehicle {
                    builderResult.vehicle = try TransitRealtime.VehiclePosition.builderWithPrototype(prototype:builderResult.vehicle).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.vehicle = value
                }
                builderResult.hasVehicle = true
                return self
            }
            @discardableResult
            public func clearVehicle() -> TransitRealtime.FeedEntity.Builder {
                vehicleBuilder_ = nil
                builderResult.hasVehicle = false
                builderResult.vehicle = nil
                return self
            }
            public var alert:TransitRealtime.Alert! {
                get {
                    if alertBuilder_ != nil {
                        builderResult.alert = alertBuilder_.getMessage()
                    }
                    return builderResult.alert
                }
                set (value) {
                    builderResult.hasAlert = true
                    builderResult.alert = value
                }
            }
            public var hasAlert:Bool {
                get {
                    return builderResult.hasAlert
                }
            }
            fileprivate var alertBuilder_:TransitRealtime.Alert.Builder! {
                didSet {
                    builderResult.hasAlert = true
                }
            }
            public func getAlertBuilder() -> TransitRealtime.Alert.Builder {
                if alertBuilder_ == nil {
                    alertBuilder_ = TransitRealtime.Alert.Builder()
                    builderResult.alert = alertBuilder_.getMessage()
                    if alert != nil {
                        try! alertBuilder_.mergeFrom(other: alert)
                    }
                }
                return alertBuilder_
            }
            @discardableResult
            public func setAlert(_ value:TransitRealtime.Alert!) -> TransitRealtime.FeedEntity.Builder {
                self.alert = value
                return self
            }
            @discardableResult
            public func mergeAlert(value:TransitRealtime.Alert) throws -> TransitRealtime.FeedEntity.Builder {
                if builderResult.hasAlert {
                    builderResult.alert = try TransitRealtime.Alert.builderWithPrototype(prototype:builderResult.alert).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.alert = value
                }
                builderResult.hasAlert = true
                return self
            }
            @discardableResult
            public func clearAlert() -> TransitRealtime.FeedEntity.Builder {
                alertBuilder_ = nil
                builderResult.hasAlert = false
                builderResult.alert = nil
                return self
            }
            override public var internalGetResult:ExtendableMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> TransitRealtime.FeedEntity.Builder {
                builderResult = TransitRealtime.FeedEntity()
                return self
            }
            override public func clone() throws -> TransitRealtime.FeedEntity.Builder {
                return try TransitRealtime.FeedEntity.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> TransitRealtime.FeedEntity {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> TransitRealtime.FeedEntity {
                let returnMe:TransitRealtime.FeedEntity = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:TransitRealtime.FeedEntity) throws -> TransitRealtime.FeedEntity.Builder {
                if other == TransitRealtime.FeedEntity() {
                    return self
                }
                if other.hasId {
                    id = other.id
                }
                if other.hasIsDeleted {
                    isDeleted = other.isDeleted
                }
                if (other.hasTripUpdate) {
                    try mergeTripUpdate(value: other.tripUpdate)
                }
                if (other.hasVehicle) {
                    try mergeVehicle(value: other.vehicle)
                }
                if (other.hasAlert) {
                    try mergeAlert(value: other.alert)
                }
                try mergeExtensionFields(other: other)
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.FeedEntity.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedEntity.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        id = try codedInputStream.readString()

                    case 16:
                        isDeleted = try codedInputStream.readBool()

                    case 26:
                        let subBuilder:TransitRealtime.TripUpdate.Builder = TransitRealtime.TripUpdate.Builder()
                        if hasTripUpdate {
                            try subBuilder.mergeFrom(other: tripUpdate)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        tripUpdate = subBuilder.buildPartial()

                    case 34:
                        let subBuilder:TransitRealtime.VehiclePosition.Builder = TransitRealtime.VehiclePosition.Builder()
                        if hasVehicle {
                            try subBuilder.mergeFrom(other: vehicle)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        vehicle = subBuilder.buildPartial()

                    case 42:
                        let subBuilder:TransitRealtime.Alert.Builder = TransitRealtime.Alert.Builder()
                        if hasAlert {
                            try subBuilder.mergeFrom(other: alert)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        alert = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.FeedEntity.Builder {
                let resultDecodedBuilder = TransitRealtime.FeedEntity.Builder()
                if let jsonValueId = jsonMap["id"] as? String {
                    resultDecodedBuilder.id = jsonValueId
                }
                if let jsonValueIsDeleted = jsonMap["isDeleted"] as? Bool {
                    resultDecodedBuilder.isDeleted = jsonValueIsDeleted
                }
                if let jsonValueTripUpdate = jsonMap["tripUpdate"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.tripUpdate = try TransitRealtime.TripUpdate.Builder.decodeToBuilder(jsonMap:jsonValueTripUpdate).build()

                }
                if let jsonValueVehicle = jsonMap["vehicle"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.vehicle = try TransitRealtime.VehiclePosition.Builder.decodeToBuilder(jsonMap:jsonValueVehicle).build()

                }
                if let jsonValueAlert = jsonMap["alert"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.alert = try TransitRealtime.Alert.Builder.decodeToBuilder(jsonMap:jsonValueAlert).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> TransitRealtime.FeedEntity.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try TransitRealtime.FeedEntity.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Realtime update of the progress of a vehicle along a trip.
    /// Depending on the value of ScheduleRelationship, a TripUpdate can specify:
    /// - A trip that proceeds along the schedule.
    /// - A trip that proceeds along a route but has no fixed schedule.
    /// - A trip that have been added or removed with regard to schedule.
    /// The updates can be for future, predicted arrival/departure events, or for
    /// past events that already occurred.
    /// Normally, updates should get more precise and more certain (see
    /// uncertainty below) as the events gets closer to current time.
    /// Even if that is not possible, the information for past events should be
    /// precise and certain. In particular, if an update points to time in the past
    /// but its update's uncertainty is not 0, the client should conclude that the
    /// update is a (wrong) prediction and that the trip has not completed yet.
    /// Note that the update can describe a trip that is already completed.
    /// To this end, it is enough to provide an update for the last stop of the trip.
    /// If the time of that is in the past, the client will conclude from that that
    /// the whole trip is in the past (it is possible, although inconsequential, to
    /// also provide updates for preceding stops).
    /// This option is most relevant for a trip that has completed ahead of schedule,
    /// but according to the schedule, the trip is still proceeding at the current
    /// time. Removing the updates for this trip could make the client assume
    /// that the trip is still proceeding.
    /// Note that the feed provider is allowed, but not required, to purge past
    /// updates - this is one case where this would be practically useful.
    final public class TripUpdate : ExtendableMessage {

        public static func == (lhs: TransitRealtime.TripUpdate, rhs: TransitRealtime.TripUpdate) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTrip == rhs.hasTrip) && (!lhs.hasTrip || lhs.trip == rhs.trip)
            fieldCheck = fieldCheck && (lhs.stopTimeUpdate == rhs.stopTimeUpdate)
            fieldCheck = fieldCheck && (lhs.hasVehicle == rhs.hasVehicle) && (!lhs.hasVehicle || lhs.vehicle == rhs.vehicle)
            fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
            fieldCheck = fieldCheck && (lhs.hasDelay == rhs.hasDelay) && (!lhs.hasDelay || lhs.delay == rhs.delay)
            fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:2000)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        /// Timing information for a single predicted event (either arrival or
        /// departure).
        /// Timing consists of delay and/or estimated time, and uncertainty.
        /// - delay should be used when the prediction is given relative to some
        ///   existing schedule in GTFS.
        /// - time should be given whether there is a predicted schedule or not. If
        ///   both time and delay are specified, time will take precedence
        ///   (although normally, time, if given for a scheduled trip, should be
        ///   equal to scheduled time in GTFS + delay).
        /// Uncertainty applies equally to both time and delay.
        /// The uncertainty roughly specifies the expected error in true delay (but
        /// note, we don't yet define its precise statistical meaning). It's possible
        /// for the uncertainty to be 0, for example for trains that are driven under
        /// computer timing control.
        final public class StopTimeEvent : ExtendableMessage {

            public static func == (lhs: TransitRealtime.TripUpdate.StopTimeEvent, rhs: TransitRealtime.TripUpdate.StopTimeEvent) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasDelay == rhs.hasDelay) && (!lhs.hasDelay || lhs.delay == rhs.delay)
                fieldCheck = fieldCheck && (lhs.hasTime == rhs.hasTime) && (!lhs.hasTime || lhs.time == rhs.time)
                fieldCheck = fieldCheck && (lhs.hasUncertainty == rhs.hasUncertainty) && (!lhs.hasUncertainty || lhs.uncertainty == rhs.uncertainty)
                fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:2000)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            /// Delay (in seconds) can be positive (meaning that the vehicle is late) or
            /// negative (meaning that the vehicle is ahead of schedule). Delay of 0
            /// means that the vehicle is exactly on time.
            public fileprivate(set) var delay:Int32 = Int32(0)
            public fileprivate(set) var hasDelay:Bool = false

            /// Event as absolute time.
            /// In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
            /// UTC).
            public fileprivate(set) var time:Int64 = Int64(0)
            public fileprivate(set) var hasTime:Bool = false

            /// If uncertainty is omitted, it is interpreted as unknown.
            /// If the prediction is unknown or too uncertain, the delay (or time) field
            /// should be empty. In such case, the uncertainty field is ignored.
            /// To specify a completely certain prediction, set its uncertainty to 0.
            public fileprivate(set) var uncertainty:Int32 = Int32(0)
            public fileprivate(set) var hasUncertainty:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                if !extensionsAreInitialized() {
                    return false
                }
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasDelay {
                    try codedOutputStream.writeInt32(fieldNumber: 1, value:delay)
                }
                if hasTime {
                    try codedOutputStream.writeInt64(fieldNumber: 2, value:time)
                }
                if hasUncertainty {
                    try codedOutputStream.writeInt32(fieldNumber: 3, value:uncertainty)
                }
                try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:2000)
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasDelay {
                    serialize_size += delay.computeInt32Size(fieldNumber: 1)
                }
                if hasTime {
                    serialize_size += time.computeInt64Size(fieldNumber: 2)
                }
                if hasUncertainty {
                    serialize_size += uncertainty.computeInt32Size(fieldNumber: 3)
                }
                serialize_size += extensionsSerializedSize()
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
                return TransitRealtime.TripUpdate.StopTimeEvent.classBuilder() as! TransitRealtime.TripUpdate.StopTimeEvent.Builder
            }
            public func getBuilder() -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
                return classBuilder() as! TransitRealtime.TripUpdate.StopTimeEvent.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return TransitRealtime.TripUpdate.StopTimeEvent.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return TransitRealtime.TripUpdate.StopTimeEvent.Builder()
            }
            public func toBuilder() throws -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
                return try TransitRealtime.TripUpdate.StopTimeEvent.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:TransitRealtime.TripUpdate.StopTimeEvent) throws -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
                return try TransitRealtime.TripUpdate.StopTimeEvent.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasDelay {
                    jsonMap["delay"] = Int(delay)
                }
                if hasTime {
                    jsonMap["time"] = "\(time)"
                }
                if hasUncertainty {
                    jsonMap["uncertainty"] = Int(uncertainty)
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.TripUpdate.StopTimeEvent {
                return try TransitRealtime.TripUpdate.StopTimeEvent.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> TransitRealtime.TripUpdate.StopTimeEvent {
                return try TransitRealtime.TripUpdate.StopTimeEvent.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasDelay {
                    output += "\(indent) delay: \(delay) \n"
                }
                if hasTime {
                    output += "\(indent) time: \(time) \n"
                }
                if hasUncertainty {
                    output += "\(indent) uncertainty: \(uncertainty) \n"
                }
                output += try getExtensionDescription(startInclusive:1000, endExclusive:2000, indent:indent)
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasDelay {
                        hashCode = (hashCode &* 31) &+ delay.hashValue
                    }
                    if hasTime {
                        hashCode = (hashCode &* 31) &+ time.hashValue
                    }
                    if hasUncertainty {
                        hashCode = (hashCode &* 31) &+ uncertainty.hashValue
                    }
                    hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:2000))
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "TransitRealtime.TripUpdate.StopTimeEvent"
            }
            override public func className() -> String {
                return "TransitRealtime.TripUpdate.StopTimeEvent"
            }
            //Meta information declaration end

            final public class Builder : ExtendableMessageBuilder {
                fileprivate var builderResult:TransitRealtime.TripUpdate.StopTimeEvent = TransitRealtime.TripUpdate.StopTimeEvent()
                public func getMessage() -> TransitRealtime.TripUpdate.StopTimeEvent {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                /// Delay (in seconds) can be positive (meaning that the vehicle is late) or
                /// negative (meaning that the vehicle is ahead of schedule). Delay of 0
                /// means that the vehicle is exactly on time.
                public var delay:Int32 {
                    get {
                        return builderResult.delay
                    }
                    set (value) {
                        builderResult.hasDelay = true
                        builderResult.delay = value
                    }
                }
                public var hasDelay:Bool {
                    get {
                        return builderResult.hasDelay
                    }
                }
                @discardableResult
                public func setDelay(_ value:Int32) -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
                    self.delay = value
                    return self
                }
                @discardableResult
                public func clearDelay() -> TransitRealtime.TripUpdate.StopTimeEvent.Builder{
                    builderResult.hasDelay = false
                    builderResult.delay = Int32(0)
                    return self
                }
                /// Event as absolute time.
                /// In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
                /// UTC).
                public var time:Int64 {
                    get {
                        return builderResult.time
                    }
                    set (value) {
                        builderResult.hasTime = true
                        builderResult.time = value
                    }
                }
                public var hasTime:Bool {
                    get {
                        return builderResult.hasTime
                    }
                }
                @discardableResult
                public func setTime(_ value:Int64) -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
                    self.time = value
                    return self
                }
                @discardableResult
                public func clearTime() -> TransitRealtime.TripUpdate.StopTimeEvent.Builder{
                    builderResult.hasTime = false
                    builderResult.time = Int64(0)
                    return self
                }
                /// If uncertainty is omitted, it is interpreted as unknown.
                /// If the prediction is unknown or too uncertain, the delay (or time) field
                /// should be empty. In such case, the uncertainty field is ignored.
                /// To specify a completely certain prediction, set its uncertainty to 0.
                public var uncertainty:Int32 {
                    get {
                        return builderResult.uncertainty
                    }
                    set (value) {
                        builderResult.hasUncertainty = true
                        builderResult.uncertainty = value
                    }
                }
                public var hasUncertainty:Bool {
                    get {
                        return builderResult.hasUncertainty
                    }
                }
                @discardableResult
                public func setUncertainty(_ value:Int32) -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
                    self.uncertainty = value
                    return self
                }
                @discardableResult
                public func clearUncertainty() -> TransitRealtime.TripUpdate.StopTimeEvent.Builder{
                    builderResult.hasUncertainty = false
                    builderResult.uncertainty = Int32(0)
                    return self
                }
                override public var internalGetResult:ExtendableMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
                    builderResult = TransitRealtime.TripUpdate.StopTimeEvent()
                    return self
                }
                override public func clone() throws -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
                    return try TransitRealtime.TripUpdate.StopTimeEvent.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> TransitRealtime.TripUpdate.StopTimeEvent {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> TransitRealtime.TripUpdate.StopTimeEvent {
                    let returnMe:TransitRealtime.TripUpdate.StopTimeEvent = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:TransitRealtime.TripUpdate.StopTimeEvent) throws -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
                    if other == TransitRealtime.TripUpdate.StopTimeEvent() {
                        return self
                    }
                    if other.hasDelay {
                        delay = other.delay
                    }
                    if other.hasTime {
                        time = other.time
                    }
                    if other.hasUncertainty {
                        uncertainty = other.uncertainty
                    }
                    try mergeExtensionFields(other: other)
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 8:
                            delay = try codedInputStream.readInt32()

                        case 16:
                            time = try codedInputStream.readInt64()

                        case 24:
                            uncertainty = try codedInputStream.readInt32()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
                    let resultDecodedBuilder = TransitRealtime.TripUpdate.StopTimeEvent.Builder()
                    if let jsonValueDelay = jsonMap["delay"] as? Int {
                        resultDecodedBuilder.delay = Int32(jsonValueDelay)
                    } else if let jsonValueDelay = jsonMap["delay"] as? String {
                        resultDecodedBuilder.delay = Int32(jsonValueDelay)!
                    }
                    if let jsonValueTime = jsonMap["time"] as? String {
                        resultDecodedBuilder.time = Int64(jsonValueTime)!
                    } else if let jsonValueTime = jsonMap["time"] as? Int {
                        resultDecodedBuilder.time = Int64(jsonValueTime)
                    }
                    if let jsonValueUncertainty = jsonMap["uncertainty"] as? Int {
                        resultDecodedBuilder.uncertainty = Int32(jsonValueUncertainty)
                    } else if let jsonValueUncertainty = jsonMap["uncertainty"] as? String {
                        resultDecodedBuilder.uncertainty = Int32(jsonValueUncertainty)!
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try TransitRealtime.TripUpdate.StopTimeEvent.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end



        //Nested type declaration start

        /// Realtime update for arrival and/or departure events for a given stop on a
        /// trip. Updates can be supplied for both past and future events.
        /// The producer is allowed, although not required, to drop past events.
        final public class StopTimeUpdate : ExtendableMessage {

            public static func == (lhs: TransitRealtime.TripUpdate.StopTimeUpdate, rhs: TransitRealtime.TripUpdate.StopTimeUpdate) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasStopSequence == rhs.hasStopSequence) && (!lhs.hasStopSequence || lhs.stopSequence == rhs.stopSequence)
                fieldCheck = fieldCheck && (lhs.hasArrival == rhs.hasArrival) && (!lhs.hasArrival || lhs.arrival == rhs.arrival)
                fieldCheck = fieldCheck && (lhs.hasDeparture == rhs.hasDeparture) && (!lhs.hasDeparture || lhs.departure == rhs.departure)
                fieldCheck = fieldCheck && (lhs.hasStopId == rhs.hasStopId) && (!lhs.hasStopId || lhs.stopId == rhs.stopId)
                fieldCheck = fieldCheck && (lhs.hasScheduleRelationship == rhs.hasScheduleRelationship) && (!lhs.hasScheduleRelationship || lhs.scheduleRelationship == rhs.scheduleRelationship)
                fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:2000)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }



                //Enum type declaration start 

                /// The relation between this StopTime and the static schedule.
                public enum ScheduleRelationship:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                    /// The vehicle is proceeding in accordance with its static schedule of
                    /// stops, although not necessarily according to the times of the schedule.
                    /// At least one of arrival and departure must be provided. If the schedule
                    /// for this stop contains both arrival and departure times then so must
                    /// this update.
                    case scheduled = 0

                    /// The stop is skipped, i.e., the vehicle will not stop at this stop.
                    /// Arrival and departure are optional.
                    case skipped = 1

                    /// No data is given for this stop. The main intention for this value is to
                    /// give the predictions only for part of a trip, i.e., if the last update
                    /// for a trip has a NO_DATA specifier, then StopTimes for the rest of the
                    /// stops in the trip are considered to be unspecified as well.
                    /// Neither arrival nor departure should be supplied.
                    case noData = 2
                    public func toString() -> String {
                        switch self {
                        case .scheduled: return "SCHEDULED"
                        case .skipped: return "SKIPPED"
                        case .noData: return "NO_DATA"
                        }
                    }
                    public static func fromString(str:String) throws -> TransitRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship {
                        switch str {
                        case "SCHEDULED":    return .scheduled
                        case "SKIPPED":    return .skipped
                        case "NO_DATA":    return .noData
                        default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                        }
                    }
                    public var debugDescription:String { return getDescription() }
                    public var description:String { return getDescription() }
                    private func getDescription() -> String { 
                        switch self {
                        case .scheduled: return ".scheduled"
                        case .skipped: return ".skipped"
                        case .noData: return ".noData"
                        }
                    }
                    public var hashValue:Int {
                        return self.rawValue.hashValue
                    }
                    public static func ==(lhs:ScheduleRelationship, rhs:ScheduleRelationship) -> Bool {
                        return lhs.hashValue == rhs.hashValue
                    }
                }

                //Enum type declaration end 

            /// Must be the same as in stop_times.txt in the corresponding GTFS feed.
            public fileprivate(set) var stopSequence:UInt32 = UInt32(0)
            public fileprivate(set) var hasStopSequence:Bool = false

            /// Must be the same as in stops.txt in the corresponding GTFS feed.
            public fileprivate(set) var stopId:String = ""
            public fileprivate(set) var hasStopId:Bool = false

            public fileprivate(set) var arrival:TransitRealtime.TripUpdate.StopTimeEvent!
            public fileprivate(set) var hasArrival:Bool = false
            public fileprivate(set) var departure:TransitRealtime.TripUpdate.StopTimeEvent!
            public fileprivate(set) var hasDeparture:Bool = false
            public fileprivate(set) var scheduleRelationship:TransitRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship = TransitRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.scheduled
            public fileprivate(set) var hasScheduleRelationship:Bool = false
            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                if hasArrival {
                    if !arrival.isInitialized() {
                        return false
                    }
                }
                if hasDeparture {
                    if !departure.isInitialized() {
                        return false
                    }
                }
                if !extensionsAreInitialized() {
                    return false
                }
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasStopSequence {
                    try codedOutputStream.writeUInt32(fieldNumber: 1, value:stopSequence)
                }
                if hasArrival {
                    try codedOutputStream.writeMessage(fieldNumber: 2, value:arrival)
                }
                if hasDeparture {
                    try codedOutputStream.writeMessage(fieldNumber: 3, value:departure)
                }
                if hasStopId {
                    try codedOutputStream.writeString(fieldNumber: 4, value:stopId)
                }
                if hasScheduleRelationship {
                    try codedOutputStream.writeEnum(fieldNumber: 5, value:scheduleRelationship.rawValue)
                }
                try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:2000)
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasStopSequence {
                    serialize_size += stopSequence.computeUInt32Size(fieldNumber: 1)
                }
                if hasArrival {
                    if let varSizearrival = arrival?.computeMessageSize(fieldNumber: 2) {
                        serialize_size += varSizearrival
                    }
                }
                if hasDeparture {
                    if let varSizedeparture = departure?.computeMessageSize(fieldNumber: 3) {
                        serialize_size += varSizedeparture
                    }
                }
                if hasStopId {
                    serialize_size += stopId.computeStringSize(fieldNumber: 4)
                }
                if (hasScheduleRelationship) {
                    serialize_size += scheduleRelationship.rawValue.computeEnumSize(fieldNumber: 5)
                }
                serialize_size += extensionsSerializedSize()
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
                return TransitRealtime.TripUpdate.StopTimeUpdate.classBuilder() as! TransitRealtime.TripUpdate.StopTimeUpdate.Builder
            }
            public func getBuilder() -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
                return classBuilder() as! TransitRealtime.TripUpdate.StopTimeUpdate.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return TransitRealtime.TripUpdate.StopTimeUpdate.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return TransitRealtime.TripUpdate.StopTimeUpdate.Builder()
            }
            public func toBuilder() throws -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
                return try TransitRealtime.TripUpdate.StopTimeUpdate.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:TransitRealtime.TripUpdate.StopTimeUpdate) throws -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
                return try TransitRealtime.TripUpdate.StopTimeUpdate.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasStopSequence {
                    jsonMap["stopSequence"] = UInt(stopSequence)
                }
                if hasStopId {
                    jsonMap["stopId"] = stopId
                }
                if hasArrival {
                    jsonMap["arrival"] = try arrival.encode()
                }
                if hasDeparture {
                    jsonMap["departure"] = try departure.encode()
                }
                if hasScheduleRelationship {
                    jsonMap["scheduleRelationship"] = scheduleRelationship.toString()
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.TripUpdate.StopTimeUpdate {
                return try TransitRealtime.TripUpdate.StopTimeUpdate.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> TransitRealtime.TripUpdate.StopTimeUpdate {
                return try TransitRealtime.TripUpdate.StopTimeUpdate.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasStopSequence {
                    output += "\(indent) stopSequence: \(stopSequence) \n"
                }
                if hasArrival {
                    output += "\(indent) arrival {\n"
                    if let outDescArrival = arrival {
                        output += try outDescArrival.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                if hasDeparture {
                    output += "\(indent) departure {\n"
                    if let outDescDeparture = departure {
                        output += try outDescDeparture.getDescription(indent: "\(indent)  ")
                    }
                    output += "\(indent) }\n"
                }
                if hasStopId {
                    output += "\(indent) stopId: \(stopId) \n"
                }
                if (hasScheduleRelationship) {
                    output += "\(indent) scheduleRelationship: \(scheduleRelationship.description)\n"
                }
                output += try getExtensionDescription(startInclusive:1000, endExclusive:2000, indent:indent)
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasStopSequence {
                        hashCode = (hashCode &* 31) &+ stopSequence.hashValue
                    }
                    if hasArrival {
                        if let hashValuearrival = arrival?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuearrival
                        }
                    }
                    if hasDeparture {
                        if let hashValuedeparture = departure?.hashValue {
                            hashCode = (hashCode &* 31) &+ hashValuedeparture
                        }
                    }
                    if hasStopId {
                        hashCode = (hashCode &* 31) &+ stopId.hashValue
                    }
                    if hasScheduleRelationship {
                         hashCode = (hashCode &* 31) &+ scheduleRelationship.hashValue
                    }
                    hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:2000))
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "TransitRealtime.TripUpdate.StopTimeUpdate"
            }
            override public func className() -> String {
                return "TransitRealtime.TripUpdate.StopTimeUpdate"
            }
            //Meta information declaration end

            final public class Builder : ExtendableMessageBuilder {
                fileprivate var builderResult:TransitRealtime.TripUpdate.StopTimeUpdate = TransitRealtime.TripUpdate.StopTimeUpdate()
                public func getMessage() -> TransitRealtime.TripUpdate.StopTimeUpdate {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                /// Must be the same as in stop_times.txt in the corresponding GTFS feed.
                public var stopSequence:UInt32 {
                    get {
                        return builderResult.stopSequence
                    }
                    set (value) {
                        builderResult.hasStopSequence = true
                        builderResult.stopSequence = value
                    }
                }
                public var hasStopSequence:Bool {
                    get {
                        return builderResult.hasStopSequence
                    }
                }
                @discardableResult
                public func setStopSequence(_ value:UInt32) -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
                    self.stopSequence = value
                    return self
                }
                @discardableResult
                public func clearStopSequence() -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder{
                    builderResult.hasStopSequence = false
                    builderResult.stopSequence = UInt32(0)
                    return self
                }
                /// Must be the same as in stops.txt in the corresponding GTFS feed.
                public var stopId:String {
                    get {
                        return builderResult.stopId
                    }
                    set (value) {
                        builderResult.hasStopId = true
                        builderResult.stopId = value
                    }
                }
                public var hasStopId:Bool {
                    get {
                        return builderResult.hasStopId
                    }
                }
                @discardableResult
                public func setStopId(_ value:String) -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
                    self.stopId = value
                    return self
                }
                @discardableResult
                public func clearStopId() -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder{
                    builderResult.hasStopId = false
                    builderResult.stopId = ""
                    return self
                }
                public var arrival:TransitRealtime.TripUpdate.StopTimeEvent! {
                    get {
                        if arrivalBuilder_ != nil {
                            builderResult.arrival = arrivalBuilder_.getMessage()
                        }
                        return builderResult.arrival
                    }
                    set (value) {
                        builderResult.hasArrival = true
                        builderResult.arrival = value
                    }
                }
                public var hasArrival:Bool {
                    get {
                        return builderResult.hasArrival
                    }
                }
                fileprivate var arrivalBuilder_:TransitRealtime.TripUpdate.StopTimeEvent.Builder! {
                    didSet {
                        builderResult.hasArrival = true
                    }
                }
                public func getArrivalBuilder() -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
                    if arrivalBuilder_ == nil {
                        arrivalBuilder_ = TransitRealtime.TripUpdate.StopTimeEvent.Builder()
                        builderResult.arrival = arrivalBuilder_.getMessage()
                        if arrival != nil {
                            try! arrivalBuilder_.mergeFrom(other: arrival)
                        }
                    }
                    return arrivalBuilder_
                }
                @discardableResult
                public func setArrival(_ value:TransitRealtime.TripUpdate.StopTimeEvent!) -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
                    self.arrival = value
                    return self
                }
                @discardableResult
                public func mergeArrival(value:TransitRealtime.TripUpdate.StopTimeEvent) throws -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
                    if builderResult.hasArrival {
                        builderResult.arrival = try TransitRealtime.TripUpdate.StopTimeEvent.builderWithPrototype(prototype:builderResult.arrival).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.arrival = value
                    }
                    builderResult.hasArrival = true
                    return self
                }
                @discardableResult
                public func clearArrival() -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
                    arrivalBuilder_ = nil
                    builderResult.hasArrival = false
                    builderResult.arrival = nil
                    return self
                }
                public var departure:TransitRealtime.TripUpdate.StopTimeEvent! {
                    get {
                        if departureBuilder_ != nil {
                            builderResult.departure = departureBuilder_.getMessage()
                        }
                        return builderResult.departure
                    }
                    set (value) {
                        builderResult.hasDeparture = true
                        builderResult.departure = value
                    }
                }
                public var hasDeparture:Bool {
                    get {
                        return builderResult.hasDeparture
                    }
                }
                fileprivate var departureBuilder_:TransitRealtime.TripUpdate.StopTimeEvent.Builder! {
                    didSet {
                        builderResult.hasDeparture = true
                    }
                }
                public func getDepartureBuilder() -> TransitRealtime.TripUpdate.StopTimeEvent.Builder {
                    if departureBuilder_ == nil {
                        departureBuilder_ = TransitRealtime.TripUpdate.StopTimeEvent.Builder()
                        builderResult.departure = departureBuilder_.getMessage()
                        if departure != nil {
                            try! departureBuilder_.mergeFrom(other: departure)
                        }
                    }
                    return departureBuilder_
                }
                @discardableResult
                public func setDeparture(_ value:TransitRealtime.TripUpdate.StopTimeEvent!) -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
                    self.departure = value
                    return self
                }
                @discardableResult
                public func mergeDeparture(value:TransitRealtime.TripUpdate.StopTimeEvent) throws -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
                    if builderResult.hasDeparture {
                        builderResult.departure = try TransitRealtime.TripUpdate.StopTimeEvent.builderWithPrototype(prototype:builderResult.departure).mergeFrom(other: value).buildPartial()
                    } else {
                        builderResult.departure = value
                    }
                    builderResult.hasDeparture = true
                    return self
                }
                @discardableResult
                public func clearDeparture() -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
                    departureBuilder_ = nil
                    builderResult.hasDeparture = false
                    builderResult.departure = nil
                    return self
                }
                    public var scheduleRelationship:TransitRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship {
                        get {
                            return builderResult.scheduleRelationship
                        }
                        set (value) {
                            builderResult.hasScheduleRelationship = true
                            builderResult.scheduleRelationship = value
                        }
                    }
                    public var hasScheduleRelationship:Bool{
                        get {
                            return builderResult.hasScheduleRelationship
                        }
                    }
                @discardableResult
                    public func setScheduleRelationship(_ value:TransitRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship) -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
                      self.scheduleRelationship = value
                      return self
                    }
                @discardableResult
                    public func clearScheduleRelationship() -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
                       builderResult.hasScheduleRelationship = false
                       builderResult.scheduleRelationship = .scheduled
                       return self
                    }
                override public var internalGetResult:ExtendableMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
                    builderResult = TransitRealtime.TripUpdate.StopTimeUpdate()
                    return self
                }
                override public func clone() throws -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
                    return try TransitRealtime.TripUpdate.StopTimeUpdate.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> TransitRealtime.TripUpdate.StopTimeUpdate {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> TransitRealtime.TripUpdate.StopTimeUpdate {
                    let returnMe:TransitRealtime.TripUpdate.StopTimeUpdate = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:TransitRealtime.TripUpdate.StopTimeUpdate) throws -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
                    if other == TransitRealtime.TripUpdate.StopTimeUpdate() {
                        return self
                    }
                    if other.hasStopSequence {
                        stopSequence = other.stopSequence
                    }
                    if other.hasStopId {
                        stopId = other.stopId
                    }
                    if (other.hasArrival) {
                        try mergeArrival(value: other.arrival)
                    }
                    if (other.hasDeparture) {
                        try mergeDeparture(value: other.departure)
                    }
                    if other.hasScheduleRelationship {
                        scheduleRelationship = other.scheduleRelationship
                    }
                    try mergeExtensionFields(other: other)
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 8:
                            stopSequence = try codedInputStream.readUInt32()

                        case 18:
                            let subBuilder:TransitRealtime.TripUpdate.StopTimeEvent.Builder = TransitRealtime.TripUpdate.StopTimeEvent.Builder()
                            if hasArrival {
                                try subBuilder.mergeFrom(other: arrival)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            arrival = subBuilder.buildPartial()

                        case 26:
                            let subBuilder:TransitRealtime.TripUpdate.StopTimeEvent.Builder = TransitRealtime.TripUpdate.StopTimeEvent.Builder()
                            if hasDeparture {
                                try subBuilder.mergeFrom(other: departure)
                            }
                            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                            departure = subBuilder.buildPartial()

                        case 34:
                            stopId = try codedInputStream.readString()

                        case 40:
                            let valueIntscheduleRelationship = try codedInputStream.readEnum()
                            if let enumsscheduleRelationship = TransitRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship(rawValue:valueIntscheduleRelationship){
                                scheduleRelationship = enumsscheduleRelationship
                            } else {
                                try unknownFieldsBuilder.mergeVarintField(fieldNumber: 5, value:Int64(valueIntscheduleRelationship))
                            }

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
                    let resultDecodedBuilder = TransitRealtime.TripUpdate.StopTimeUpdate.Builder()
                    if let jsonValueStopSequence = jsonMap["stopSequence"] as? UInt {
                        resultDecodedBuilder.stopSequence = UInt32(jsonValueStopSequence)
                    } else if let jsonValueStopSequence = jsonMap["stopSequence"] as? String {
                        resultDecodedBuilder.stopSequence = UInt32(jsonValueStopSequence)!
                    }
                    if let jsonValueStopId = jsonMap["stopId"] as? String {
                        resultDecodedBuilder.stopId = jsonValueStopId
                    }
                    if let jsonValueArrival = jsonMap["arrival"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.arrival = try TransitRealtime.TripUpdate.StopTimeEvent.Builder.decodeToBuilder(jsonMap:jsonValueArrival).build()

                    }
                    if let jsonValueDeparture = jsonMap["departure"] as? Dictionary<String,Any> {
                        resultDecodedBuilder.departure = try TransitRealtime.TripUpdate.StopTimeEvent.Builder.decodeToBuilder(jsonMap:jsonValueDeparture).build()

                    }
                    if let jsonValueScheduleRelationship = jsonMap["scheduleRelationship"] as? String {
                        resultDecodedBuilder.scheduleRelationship = try TransitRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.fromString(str: jsonValueScheduleRelationship)
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> TransitRealtime.TripUpdate.StopTimeUpdate.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try TransitRealtime.TripUpdate.StopTimeUpdate.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        public fileprivate(set) var trip:TransitRealtime.TripDescriptor!
        public fileprivate(set) var hasTrip:Bool = false
        public fileprivate(set) var vehicle:TransitRealtime.VehicleDescriptor!
        public fileprivate(set) var hasVehicle:Bool = false
        public fileprivate(set) var stopTimeUpdate:Array<TransitRealtime.TripUpdate.StopTimeUpdate>  = Array<TransitRealtime.TripUpdate.StopTimeUpdate>()
        /// Moment at which the vehicle's real-time progress was measured. In POSIX
        /// time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
        public fileprivate(set) var timestamp:UInt64 = UInt64(0)
        public fileprivate(set) var hasTimestamp:Bool = false

        /// The current schedule deviation for the trip.  Delay should only be
        /// specified when the prediction is given relative to some existing schedule
        /// in GTFS.
        /// Delay (in seconds) can be positive (meaning that the vehicle is late) or
        /// negative (meaning that the vehicle is ahead of schedule). Delay of 0
        /// means that the vehicle is exactly on time.
        /// Delay information in StopTimeUpdates take precedent of trip-level delay
        /// information, such that trip-level delay is only propagated until the next
        /// stop along the trip with a StopTimeUpdate delay value specified.
        /// Feed providers are strongly encouraged to provide a TripUpdate.timestamp
        /// value indicating when the delay value was last updated, in order to
        /// evaluate the freshness of the data.
        /// NOTE: This field is still experimental, and subject to change. It may be
        /// formally adopted in the future.
        public fileprivate(set) var delay:Int32 = Int32(0)
        public fileprivate(set) var hasDelay:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasTrip {
                return false
            }
            if !trip.isInitialized() {
                return false
            }
            if hasVehicle {
                if !vehicle.isInitialized() {
                    return false
                }
            }
            var isInitStopTimeUpdate:Bool = true
            for oneElementStopTimeUpdate in stopTimeUpdate {
                if !oneElementStopTimeUpdate.isInitialized() {
                    isInitStopTimeUpdate = false
                    break 
                }
            }
            if !isInitStopTimeUpdate {
                return isInitStopTimeUpdate
            }
            if !extensionsAreInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTrip {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:trip)
            }
            for oneElementStopTimeUpdate in stopTimeUpdate {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementStopTimeUpdate)
            }
            if hasVehicle {
                try codedOutputStream.writeMessage(fieldNumber: 3, value:vehicle)
            }
            if hasTimestamp {
                try codedOutputStream.writeUInt64(fieldNumber: 4, value:timestamp)
            }
            if hasDelay {
                try codedOutputStream.writeInt32(fieldNumber: 5, value:delay)
            }
            try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:2000)
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTrip {
                if let varSizetrip = trip?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizetrip
                }
            }
            for oneElementStopTimeUpdate in stopTimeUpdate {
                serialize_size += oneElementStopTimeUpdate.computeMessageSize(fieldNumber: 2)
            }
            if hasVehicle {
                if let varSizevehicle = vehicle?.computeMessageSize(fieldNumber: 3) {
                    serialize_size += varSizevehicle
                }
            }
            if hasTimestamp {
                serialize_size += timestamp.computeUInt64Size(fieldNumber: 4)
            }
            if hasDelay {
                serialize_size += delay.computeInt32Size(fieldNumber: 5)
            }
            serialize_size += extensionsSerializedSize()
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> TransitRealtime.TripUpdate.Builder {
            return TransitRealtime.TripUpdate.classBuilder() as! TransitRealtime.TripUpdate.Builder
        }
        public func getBuilder() -> TransitRealtime.TripUpdate.Builder {
            return classBuilder() as! TransitRealtime.TripUpdate.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.TripUpdate.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.TripUpdate.Builder()
        }
        public func toBuilder() throws -> TransitRealtime.TripUpdate.Builder {
            return try TransitRealtime.TripUpdate.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:TransitRealtime.TripUpdate) throws -> TransitRealtime.TripUpdate.Builder {
            return try TransitRealtime.TripUpdate.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTrip {
                jsonMap["trip"] = try trip.encode()
            }
            if hasVehicle {
                jsonMap["vehicle"] = try vehicle.encode()
            }
            if !stopTimeUpdate.isEmpty {
                var jsonArrayStopTimeUpdate:Array<Dictionary<String,Any>> = []
                for oneValueStopTimeUpdate in stopTimeUpdate {
                    let ecodedMessageStopTimeUpdate = try oneValueStopTimeUpdate.encode()
                    jsonArrayStopTimeUpdate.append(ecodedMessageStopTimeUpdate)
                }
                jsonMap["stopTimeUpdate"] = jsonArrayStopTimeUpdate
            }
            if hasTimestamp {
                jsonMap["timestamp"] = "\(timestamp)"
            }
            if hasDelay {
                jsonMap["delay"] = Int(delay)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.TripUpdate {
            return try TransitRealtime.TripUpdate.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> TransitRealtime.TripUpdate {
            return try TransitRealtime.TripUpdate.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTrip {
                output += "\(indent) trip {\n"
                if let outDescTrip = trip {
                    output += try outDescTrip.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            var stopTimeUpdateElementIndex:Int = 0
            for oneElementStopTimeUpdate in stopTimeUpdate {
                output += "\(indent) stopTimeUpdate[\(stopTimeUpdateElementIndex)] {\n"
                output += try oneElementStopTimeUpdate.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                stopTimeUpdateElementIndex += 1
            }
            if hasVehicle {
                output += "\(indent) vehicle {\n"
                if let outDescVehicle = vehicle {
                    output += try outDescVehicle.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasTimestamp {
                output += "\(indent) timestamp: \(timestamp) \n"
            }
            if hasDelay {
                output += "\(indent) delay: \(delay) \n"
            }
            output += try getExtensionDescription(startInclusive:1000, endExclusive:2000, indent:indent)
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTrip {
                    if let hashValuetrip = trip?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetrip
                    }
                }
                for oneElementStopTimeUpdate in stopTimeUpdate {
                    hashCode = (hashCode &* 31) &+ oneElementStopTimeUpdate.hashValue
                }
                if hasVehicle {
                    if let hashValuevehicle = vehicle?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuevehicle
                    }
                }
                if hasTimestamp {
                    hashCode = (hashCode &* 31) &+ timestamp.hashValue
                }
                if hasDelay {
                    hashCode = (hashCode &* 31) &+ delay.hashValue
                }
                hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:2000))
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "TransitRealtime.TripUpdate"
        }
        override public func className() -> String {
            return "TransitRealtime.TripUpdate"
        }
        //Meta information declaration end

        final public class Builder : ExtendableMessageBuilder {
            fileprivate var builderResult:TransitRealtime.TripUpdate = TransitRealtime.TripUpdate()
            public func getMessage() -> TransitRealtime.TripUpdate {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The Trip that this message applies to. There can be at most one
            /// TripUpdate entity for each actual trip instance.
            /// If there is none, that means there is no prediction information available.
            /// It does *not* mean that the trip is progressing according to schedule.
            public var trip:TransitRealtime.TripDescriptor! {
                get {
                    if tripBuilder_ != nil {
                        builderResult.trip = tripBuilder_.getMessage()
                    }
                    return builderResult.trip
                }
                set (value) {
                    builderResult.hasTrip = true
                    builderResult.trip = value
                }
            }
            public var hasTrip:Bool {
                get {
                    return builderResult.hasTrip
                }
            }
            fileprivate var tripBuilder_:TransitRealtime.TripDescriptor.Builder! {
                didSet {
                    builderResult.hasTrip = true
                }
            }
            public func getTripBuilder() -> TransitRealtime.TripDescriptor.Builder {
                if tripBuilder_ == nil {
                    tripBuilder_ = TransitRealtime.TripDescriptor.Builder()
                    builderResult.trip = tripBuilder_.getMessage()
                    if trip != nil {
                        try! tripBuilder_.mergeFrom(other: trip)
                    }
                }
                return tripBuilder_
            }
            @discardableResult
            public func setTrip(_ value:TransitRealtime.TripDescriptor!) -> TransitRealtime.TripUpdate.Builder {
                self.trip = value
                return self
            }
            @discardableResult
            public func mergeTrip(value:TransitRealtime.TripDescriptor) throws -> TransitRealtime.TripUpdate.Builder {
                if builderResult.hasTrip {
                    builderResult.trip = try TransitRealtime.TripDescriptor.builderWithPrototype(prototype:builderResult.trip).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.trip = value
                }
                builderResult.hasTrip = true
                return self
            }
            @discardableResult
            public func clearTrip() -> TransitRealtime.TripUpdate.Builder {
                tripBuilder_ = nil
                builderResult.hasTrip = false
                builderResult.trip = nil
                return self
            }
            /// Additional information on the vehicle that is serving this trip.
            public var vehicle:TransitRealtime.VehicleDescriptor! {
                get {
                    if vehicleBuilder_ != nil {
                        builderResult.vehicle = vehicleBuilder_.getMessage()
                    }
                    return builderResult.vehicle
                }
                set (value) {
                    builderResult.hasVehicle = true
                    builderResult.vehicle = value
                }
            }
            public var hasVehicle:Bool {
                get {
                    return builderResult.hasVehicle
                }
            }
            fileprivate var vehicleBuilder_:TransitRealtime.VehicleDescriptor.Builder! {
                didSet {
                    builderResult.hasVehicle = true
                }
            }
            public func getVehicleBuilder() -> TransitRealtime.VehicleDescriptor.Builder {
                if vehicleBuilder_ == nil {
                    vehicleBuilder_ = TransitRealtime.VehicleDescriptor.Builder()
                    builderResult.vehicle = vehicleBuilder_.getMessage()
                    if vehicle != nil {
                        try! vehicleBuilder_.mergeFrom(other: vehicle)
                    }
                }
                return vehicleBuilder_
            }
            @discardableResult
            public func setVehicle(_ value:TransitRealtime.VehicleDescriptor!) -> TransitRealtime.TripUpdate.Builder {
                self.vehicle = value
                return self
            }
            @discardableResult
            public func mergeVehicle(value:TransitRealtime.VehicleDescriptor) throws -> TransitRealtime.TripUpdate.Builder {
                if builderResult.hasVehicle {
                    builderResult.vehicle = try TransitRealtime.VehicleDescriptor.builderWithPrototype(prototype:builderResult.vehicle).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.vehicle = value
                }
                builderResult.hasVehicle = true
                return self
            }
            @discardableResult
            public func clearVehicle() -> TransitRealtime.TripUpdate.Builder {
                vehicleBuilder_ = nil
                builderResult.hasVehicle = false
                builderResult.vehicle = nil
                return self
            }
            /// Updates to StopTimes for the trip (both future, i.e., predictions, and in
            /// some cases, past ones, i.e., those that already happened).
            /// The updates must be sorted by stop_sequence, and apply for all the
            /// following stops of the trip up to the next specified one.
            /// Example 1:
            /// For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
            /// delay of 0 for stop_sequence of the current stop means that the trip is
            /// exactly on time.
            /// Example 2:
            /// For the same trip instance, 3 StopTimeUpdates are provided:
            /// - delay of 5 min for stop_sequence 3
            /// - delay of 1 min for stop_sequence 8
            /// - delay of unspecified duration for stop_sequence 10
            /// This will be interpreted as:
            /// - stop_sequences 3,4,5,6,7 have delay of 5 min.
            /// - stop_sequences 8,9 have delay of 1 min.
            /// - stop_sequences 10,... have unknown delay.
            public var stopTimeUpdate:Array<TransitRealtime.TripUpdate.StopTimeUpdate> {
                get {
                    return builderResult.stopTimeUpdate
                }
                set (value) {
                    builderResult.stopTimeUpdate = value
                }
            }
            @discardableResult
            public func setStopTimeUpdate(_ value:Array<TransitRealtime.TripUpdate.StopTimeUpdate>) -> TransitRealtime.TripUpdate.Builder {
                self.stopTimeUpdate = value
                return self
            }
            @discardableResult
            public func clearStopTimeUpdate() -> TransitRealtime.TripUpdate.Builder {
                builderResult.stopTimeUpdate.removeAll(keepingCapacity: false)
                return self
            }
            /// Moment at which the vehicle's real-time progress was measured. In POSIX
            /// time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
            public var timestamp:UInt64 {
                get {
                    return builderResult.timestamp
                }
                set (value) {
                    builderResult.hasTimestamp = true
                    builderResult.timestamp = value
                }
            }
            public var hasTimestamp:Bool {
                get {
                    return builderResult.hasTimestamp
                }
            }
            @discardableResult
            public func setTimestamp(_ value:UInt64) -> TransitRealtime.TripUpdate.Builder {
                self.timestamp = value
                return self
            }
            @discardableResult
            public func clearTimestamp() -> TransitRealtime.TripUpdate.Builder{
                builderResult.hasTimestamp = false
                builderResult.timestamp = UInt64(0)
                return self
            }
            /// The current schedule deviation for the trip.  Delay should only be
            /// specified when the prediction is given relative to some existing schedule
            /// in GTFS.
            /// Delay (in seconds) can be positive (meaning that the vehicle is late) or
            /// negative (meaning that the vehicle is ahead of schedule). Delay of 0
            /// means that the vehicle is exactly on time.
            /// Delay information in StopTimeUpdates take precedent of trip-level delay
            /// information, such that trip-level delay is only propagated until the next
            /// stop along the trip with a StopTimeUpdate delay value specified.
            /// Feed providers are strongly encouraged to provide a TripUpdate.timestamp
            /// value indicating when the delay value was last updated, in order to
            /// evaluate the freshness of the data.
            /// NOTE: This field is still experimental, and subject to change. It may be
            /// formally adopted in the future.
            public var delay:Int32 {
                get {
                    return builderResult.delay
                }
                set (value) {
                    builderResult.hasDelay = true
                    builderResult.delay = value
                }
            }
            public var hasDelay:Bool {
                get {
                    return builderResult.hasDelay
                }
            }
            @discardableResult
            public func setDelay(_ value:Int32) -> TransitRealtime.TripUpdate.Builder {
                self.delay = value
                return self
            }
            @discardableResult
            public func clearDelay() -> TransitRealtime.TripUpdate.Builder{
                builderResult.hasDelay = false
                builderResult.delay = Int32(0)
                return self
            }
            override public var internalGetResult:ExtendableMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> TransitRealtime.TripUpdate.Builder {
                builderResult = TransitRealtime.TripUpdate()
                return self
            }
            override public func clone() throws -> TransitRealtime.TripUpdate.Builder {
                return try TransitRealtime.TripUpdate.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> TransitRealtime.TripUpdate {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> TransitRealtime.TripUpdate {
                let returnMe:TransitRealtime.TripUpdate = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:TransitRealtime.TripUpdate) throws -> TransitRealtime.TripUpdate.Builder {
                if other == TransitRealtime.TripUpdate() {
                    return self
                }
                if (other.hasTrip) {
                    try mergeTrip(value: other.trip)
                }
                if (other.hasVehicle) {
                    try mergeVehicle(value: other.vehicle)
                }
                if !other.stopTimeUpdate.isEmpty  {
                     builderResult.stopTimeUpdate += other.stopTimeUpdate
                }
                if other.hasTimestamp {
                    timestamp = other.timestamp
                }
                if other.hasDelay {
                    delay = other.delay
                }
                try mergeExtensionFields(other: other)
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.TripUpdate.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:TransitRealtime.TripDescriptor.Builder = TransitRealtime.TripDescriptor.Builder()
                        if hasTrip {
                            try subBuilder.mergeFrom(other: trip)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        trip = subBuilder.buildPartial()

                    case 18:
                        let subBuilder = TransitRealtime.TripUpdate.StopTimeUpdate.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        stopTimeUpdate.append(subBuilder.buildPartial())

                    case 26:
                        let subBuilder:TransitRealtime.VehicleDescriptor.Builder = TransitRealtime.VehicleDescriptor.Builder()
                        if hasVehicle {
                            try subBuilder.mergeFrom(other: vehicle)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        vehicle = subBuilder.buildPartial()

                    case 32:
                        timestamp = try codedInputStream.readUInt64()

                    case 40:
                        delay = try codedInputStream.readInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.TripUpdate.Builder {
                let resultDecodedBuilder = TransitRealtime.TripUpdate.Builder()
                if let jsonValueTrip = jsonMap["trip"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.trip = try TransitRealtime.TripDescriptor.Builder.decodeToBuilder(jsonMap:jsonValueTrip).build()

                }
                if let jsonValueVehicle = jsonMap["vehicle"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.vehicle = try TransitRealtime.VehicleDescriptor.Builder.decodeToBuilder(jsonMap:jsonValueVehicle).build()

                }
                if let jsonValueStopTimeUpdate = jsonMap["stopTimeUpdate"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayStopTimeUpdate:Array<TransitRealtime.TripUpdate.StopTimeUpdate> = []
                    for oneValueStopTimeUpdate in jsonValueStopTimeUpdate {
                        let messageFromStringStopTimeUpdate = try TransitRealtime.TripUpdate.StopTimeUpdate.Builder.decodeToBuilder(jsonMap:oneValueStopTimeUpdate).build()

                        jsonArrayStopTimeUpdate.append(messageFromStringStopTimeUpdate)
                    }
                    resultDecodedBuilder.stopTimeUpdate = jsonArrayStopTimeUpdate
                }
                if let jsonValueTimestamp = jsonMap["timestamp"] as? String {
                    resultDecodedBuilder.timestamp = UInt64(jsonValueTimestamp)!
                } else if let jsonValueTimestamp = jsonMap["timestamp"] as? UInt {
                    resultDecodedBuilder.timestamp = UInt64(jsonValueTimestamp)
                }
                if let jsonValueDelay = jsonMap["delay"] as? Int {
                    resultDecodedBuilder.delay = Int32(jsonValueDelay)
                } else if let jsonValueDelay = jsonMap["delay"] as? String {
                    resultDecodedBuilder.delay = Int32(jsonValueDelay)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> TransitRealtime.TripUpdate.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try TransitRealtime.TripUpdate.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Realtime positioning information for a given vehicle.
    final public class VehiclePosition : ExtendableMessage {

        public static func == (lhs: TransitRealtime.VehiclePosition, rhs: TransitRealtime.VehiclePosition) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTrip == rhs.hasTrip) && (!lhs.hasTrip || lhs.trip == rhs.trip)
            fieldCheck = fieldCheck && (lhs.hasPosition == rhs.hasPosition) && (!lhs.hasPosition || lhs.position == rhs.position)
            fieldCheck = fieldCheck && (lhs.hasCurrentStopSequence == rhs.hasCurrentStopSequence) && (!lhs.hasCurrentStopSequence || lhs.currentStopSequence == rhs.currentStopSequence)
            fieldCheck = fieldCheck && (lhs.hasCurrentStatus == rhs.hasCurrentStatus) && (!lhs.hasCurrentStatus || lhs.currentStatus == rhs.currentStatus)
            fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
            fieldCheck = fieldCheck && (lhs.hasCongestionLevel == rhs.hasCongestionLevel) && (!lhs.hasCongestionLevel || lhs.congestionLevel == rhs.congestionLevel)
            fieldCheck = fieldCheck && (lhs.hasStopId == rhs.hasStopId) && (!lhs.hasStopId || lhs.stopId == rhs.stopId)
            fieldCheck = fieldCheck && (lhs.hasVehicle == rhs.hasVehicle) && (!lhs.hasVehicle || lhs.vehicle == rhs.vehicle)
            fieldCheck = fieldCheck && (lhs.hasOccupancyStatus == rhs.hasOccupancyStatus) && (!lhs.hasOccupancyStatus || lhs.occupancyStatus == rhs.occupancyStatus)
            fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:2000)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



            //Enum type declaration start 

            public enum VehicleStopStatus:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                /// The vehicle is just about to arrive at the stop (on a stop
                /// display, the vehicle symbol typically flashes).
                case incomingAt = 0

                /// The vehicle is standing at the stop.
                case stoppedAt = 1

                /// The vehicle has departed and is in transit to the next stop.
                case inTransitTo = 2
                public func toString() -> String {
                    switch self {
                    case .incomingAt: return "INCOMING_AT"
                    case .stoppedAt: return "STOPPED_AT"
                    case .inTransitTo: return "IN_TRANSIT_TO"
                    }
                }
                public static func fromString(str:String) throws -> TransitRealtime.VehiclePosition.VehicleStopStatus {
                    switch str {
                    case "INCOMING_AT":    return .incomingAt
                    case "STOPPED_AT":    return .stoppedAt
                    case "IN_TRANSIT_TO":    return .inTransitTo
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .incomingAt: return ".incomingAt"
                    case .stoppedAt: return ".stoppedAt"
                    case .inTransitTo: return ".inTransitTo"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:VehicleStopStatus, rhs:VehicleStopStatus) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 



            //Enum type declaration start 

            /// Congestion level that is affecting this vehicle.
            public enum CongestionLevel:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                case unknownCongestionLevel = 0
                case runningSmoothly = 1
                case stopAndGo = 2
                case congestion = 3

                /// People leaving their cars.
                case severeCongestion = 4
                public func toString() -> String {
                    switch self {
                    case .unknownCongestionLevel: return "UNKNOWN_CONGESTION_LEVEL"
                    case .runningSmoothly: return "RUNNING_SMOOTHLY"
                    case .stopAndGo: return "STOP_AND_GO"
                    case .congestion: return "CONGESTION"
                    case .severeCongestion: return "SEVERE_CONGESTION"
                    }
                }
                public static func fromString(str:String) throws -> TransitRealtime.VehiclePosition.CongestionLevel {
                    switch str {
                    case "UNKNOWN_CONGESTION_LEVEL":    return .unknownCongestionLevel
                    case "RUNNING_SMOOTHLY":    return .runningSmoothly
                    case "STOP_AND_GO":    return .stopAndGo
                    case "CONGESTION":    return .congestion
                    case "SEVERE_CONGESTION":    return .severeCongestion
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .unknownCongestionLevel: return ".unknownCongestionLevel"
                    case .runningSmoothly: return ".runningSmoothly"
                    case .stopAndGo: return ".stopAndGo"
                    case .congestion: return ".congestion"
                    case .severeCongestion: return ".severeCongestion"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:CongestionLevel, rhs:CongestionLevel) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 



            //Enum type declaration start 

            /// The degree of passenger occupancy of the vehicle. This field is still
            /// experimental, and subject to change. It may be formally adopted in the
            /// future.
            public enum OccupancyStatus:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                /// The vehicle is considered empty by most measures, and has few or no
                /// passengers onboard, but is still accepting passengers.
                case empty = 0

                /// The vehicle has a relatively large percentage of seats available.
                /// What percentage of free seats out of the total seats available is to be
                /// considered large enough to fall into this category is determined at the
                /// discretion of the producer.
                case manySeatsAvailable = 1

                /// The vehicle has a relatively small percentage of seats available.
                /// What percentage of free seats out of the total seats available is to be
                /// considered small enough to fall into this category is determined at the
                /// discretion of the feed producer.
                case fewSeatsAvailable = 2

                /// The vehicle can currently accommodate only standing passengers.
                case standingRoomOnly = 3

                /// The vehicle can currently accommodate only standing passengers
                /// and has limited space for them.
                case crushedStandingRoomOnly = 4

                /// The vehicle is considered full by most measures, but may still be
                /// allowing passengers to board.
                case full = 5

                /// The vehicle is not accepting additional passengers.
                case notAcceptingPassengers = 6
                public func toString() -> String {
                    switch self {
                    case .empty: return "EMPTY"
                    case .manySeatsAvailable: return "MANY_SEATS_AVAILABLE"
                    case .fewSeatsAvailable: return "FEW_SEATS_AVAILABLE"
                    case .standingRoomOnly: return "STANDING_ROOM_ONLY"
                    case .crushedStandingRoomOnly: return "CRUSHED_STANDING_ROOM_ONLY"
                    case .full: return "FULL"
                    case .notAcceptingPassengers: return "NOT_ACCEPTING_PASSENGERS"
                    }
                }
                public static func fromString(str:String) throws -> TransitRealtime.VehiclePosition.OccupancyStatus {
                    switch str {
                    case "EMPTY":    return .empty
                    case "MANY_SEATS_AVAILABLE":    return .manySeatsAvailable
                    case "FEW_SEATS_AVAILABLE":    return .fewSeatsAvailable
                    case "STANDING_ROOM_ONLY":    return .standingRoomOnly
                    case "CRUSHED_STANDING_ROOM_ONLY":    return .crushedStandingRoomOnly
                    case "FULL":    return .full
                    case "NOT_ACCEPTING_PASSENGERS":    return .notAcceptingPassengers
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .empty: return ".empty"
                    case .manySeatsAvailable: return ".manySeatsAvailable"
                    case .fewSeatsAvailable: return ".fewSeatsAvailable"
                    case .standingRoomOnly: return ".standingRoomOnly"
                    case .crushedStandingRoomOnly: return ".crushedStandingRoomOnly"
                    case .full: return ".full"
                    case .notAcceptingPassengers: return ".notAcceptingPassengers"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:OccupancyStatus, rhs:OccupancyStatus) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        public fileprivate(set) var trip:TransitRealtime.TripDescriptor!
        public fileprivate(set) var hasTrip:Bool = false
        public fileprivate(set) var vehicle:TransitRealtime.VehicleDescriptor!
        public fileprivate(set) var hasVehicle:Bool = false
        public fileprivate(set) var position:TransitRealtime.Position!
        public fileprivate(set) var hasPosition:Bool = false
        /// The stop sequence index of the current stop. The meaning of
        /// current_stop_sequence (i.e., the stop that it refers to) is determined by
        /// current_status.
        /// If current_status is missing IN_TRANSIT_TO is assumed.
        public fileprivate(set) var currentStopSequence:UInt32 = UInt32(0)
        public fileprivate(set) var hasCurrentStopSequence:Bool = false

        /// Identifies the current stop. The value must be the same as in stops.txt in
        /// the corresponding GTFS feed.
        public fileprivate(set) var stopId:String = ""
        public fileprivate(set) var hasStopId:Bool = false

        public fileprivate(set) var currentStatus:TransitRealtime.VehiclePosition.VehicleStopStatus = TransitRealtime.VehiclePosition.VehicleStopStatus.inTransitTo
        public fileprivate(set) var hasCurrentStatus:Bool = false
        /// Moment at which the vehicle's position was measured. In POSIX time
        /// (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
        public fileprivate(set) var timestamp:UInt64 = UInt64(0)
        public fileprivate(set) var hasTimestamp:Bool = false

        public fileprivate(set) var congestionLevel:TransitRealtime.VehiclePosition.CongestionLevel = TransitRealtime.VehiclePosition.CongestionLevel.unknownCongestionLevel
        public fileprivate(set) var hasCongestionLevel:Bool = false
        public fileprivate(set) var occupancyStatus:TransitRealtime.VehiclePosition.OccupancyStatus = TransitRealtime.VehiclePosition.OccupancyStatus.empty
        public fileprivate(set) var hasOccupancyStatus:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if hasTrip {
                if !trip.isInitialized() {
                    return false
                }
            }
            if hasVehicle {
                if !vehicle.isInitialized() {
                    return false
                }
            }
            if hasPosition {
                if !position.isInitialized() {
                    return false
                }
            }
            if !extensionsAreInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTrip {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:trip)
            }
            if hasPosition {
                try codedOutputStream.writeMessage(fieldNumber: 2, value:position)
            }
            if hasCurrentStopSequence {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:currentStopSequence)
            }
            if hasCurrentStatus {
                try codedOutputStream.writeEnum(fieldNumber: 4, value:currentStatus.rawValue)
            }
            if hasTimestamp {
                try codedOutputStream.writeUInt64(fieldNumber: 5, value:timestamp)
            }
            if hasCongestionLevel {
                try codedOutputStream.writeEnum(fieldNumber: 6, value:congestionLevel.rawValue)
            }
            if hasStopId {
                try codedOutputStream.writeString(fieldNumber: 7, value:stopId)
            }
            if hasVehicle {
                try codedOutputStream.writeMessage(fieldNumber: 8, value:vehicle)
            }
            if hasOccupancyStatus {
                try codedOutputStream.writeEnum(fieldNumber: 9, value:occupancyStatus.rawValue)
            }
            try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:2000)
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTrip {
                if let varSizetrip = trip?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizetrip
                }
            }
            if hasPosition {
                if let varSizeposition = position?.computeMessageSize(fieldNumber: 2) {
                    serialize_size += varSizeposition
                }
            }
            if hasCurrentStopSequence {
                serialize_size += currentStopSequence.computeUInt32Size(fieldNumber: 3)
            }
            if (hasCurrentStatus) {
                serialize_size += currentStatus.rawValue.computeEnumSize(fieldNumber: 4)
            }
            if hasTimestamp {
                serialize_size += timestamp.computeUInt64Size(fieldNumber: 5)
            }
            if (hasCongestionLevel) {
                serialize_size += congestionLevel.rawValue.computeEnumSize(fieldNumber: 6)
            }
            if hasStopId {
                serialize_size += stopId.computeStringSize(fieldNumber: 7)
            }
            if hasVehicle {
                if let varSizevehicle = vehicle?.computeMessageSize(fieldNumber: 8) {
                    serialize_size += varSizevehicle
                }
            }
            if (hasOccupancyStatus) {
                serialize_size += occupancyStatus.rawValue.computeEnumSize(fieldNumber: 9)
            }
            serialize_size += extensionsSerializedSize()
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> TransitRealtime.VehiclePosition.Builder {
            return TransitRealtime.VehiclePosition.classBuilder() as! TransitRealtime.VehiclePosition.Builder
        }
        public func getBuilder() -> TransitRealtime.VehiclePosition.Builder {
            return classBuilder() as! TransitRealtime.VehiclePosition.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.VehiclePosition.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.VehiclePosition.Builder()
        }
        public func toBuilder() throws -> TransitRealtime.VehiclePosition.Builder {
            return try TransitRealtime.VehiclePosition.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:TransitRealtime.VehiclePosition) throws -> TransitRealtime.VehiclePosition.Builder {
            return try TransitRealtime.VehiclePosition.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTrip {
                jsonMap["trip"] = try trip.encode()
            }
            if hasVehicle {
                jsonMap["vehicle"] = try vehicle.encode()
            }
            if hasPosition {
                jsonMap["position"] = try position.encode()
            }
            if hasCurrentStopSequence {
                jsonMap["currentStopSequence"] = UInt(currentStopSequence)
            }
            if hasStopId {
                jsonMap["stopId"] = stopId
            }
            if hasCurrentStatus {
                jsonMap["currentStatus"] = currentStatus.toString()
            }
            if hasTimestamp {
                jsonMap["timestamp"] = "\(timestamp)"
            }
            if hasCongestionLevel {
                jsonMap["congestionLevel"] = congestionLevel.toString()
            }
            if hasOccupancyStatus {
                jsonMap["occupancyStatus"] = occupancyStatus.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.VehiclePosition {
            return try TransitRealtime.VehiclePosition.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> TransitRealtime.VehiclePosition {
            return try TransitRealtime.VehiclePosition.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTrip {
                output += "\(indent) trip {\n"
                if let outDescTrip = trip {
                    output += try outDescTrip.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasPosition {
                output += "\(indent) position {\n"
                if let outDescPosition = position {
                    output += try outDescPosition.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasCurrentStopSequence {
                output += "\(indent) currentStopSequence: \(currentStopSequence) \n"
            }
            if (hasCurrentStatus) {
                output += "\(indent) currentStatus: \(currentStatus.description)\n"
            }
            if hasTimestamp {
                output += "\(indent) timestamp: \(timestamp) \n"
            }
            if (hasCongestionLevel) {
                output += "\(indent) congestionLevel: \(congestionLevel.description)\n"
            }
            if hasStopId {
                output += "\(indent) stopId: \(stopId) \n"
            }
            if hasVehicle {
                output += "\(indent) vehicle {\n"
                if let outDescVehicle = vehicle {
                    output += try outDescVehicle.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if (hasOccupancyStatus) {
                output += "\(indent) occupancyStatus: \(occupancyStatus.description)\n"
            }
            output += try getExtensionDescription(startInclusive:1000, endExclusive:2000, indent:indent)
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTrip {
                    if let hashValuetrip = trip?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetrip
                    }
                }
                if hasPosition {
                    if let hashValueposition = position?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueposition
                    }
                }
                if hasCurrentStopSequence {
                    hashCode = (hashCode &* 31) &+ currentStopSequence.hashValue
                }
                if hasCurrentStatus {
                     hashCode = (hashCode &* 31) &+ currentStatus.hashValue
                }
                if hasTimestamp {
                    hashCode = (hashCode &* 31) &+ timestamp.hashValue
                }
                if hasCongestionLevel {
                     hashCode = (hashCode &* 31) &+ congestionLevel.hashValue
                }
                if hasStopId {
                    hashCode = (hashCode &* 31) &+ stopId.hashValue
                }
                if hasVehicle {
                    if let hashValuevehicle = vehicle?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuevehicle
                    }
                }
                if hasOccupancyStatus {
                     hashCode = (hashCode &* 31) &+ occupancyStatus.hashValue
                }
                hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:2000))
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "TransitRealtime.VehiclePosition"
        }
        override public func className() -> String {
            return "TransitRealtime.VehiclePosition"
        }
        //Meta information declaration end

        final public class Builder : ExtendableMessageBuilder {
            fileprivate var builderResult:TransitRealtime.VehiclePosition = TransitRealtime.VehiclePosition()
            public func getMessage() -> TransitRealtime.VehiclePosition {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The Trip that this vehicle is serving.
            /// Can be empty or partial if the vehicle can not be identified with a given
            /// trip instance.
            public var trip:TransitRealtime.TripDescriptor! {
                get {
                    if tripBuilder_ != nil {
                        builderResult.trip = tripBuilder_.getMessage()
                    }
                    return builderResult.trip
                }
                set (value) {
                    builderResult.hasTrip = true
                    builderResult.trip = value
                }
            }
            public var hasTrip:Bool {
                get {
                    return builderResult.hasTrip
                }
            }
            fileprivate var tripBuilder_:TransitRealtime.TripDescriptor.Builder! {
                didSet {
                    builderResult.hasTrip = true
                }
            }
            public func getTripBuilder() -> TransitRealtime.TripDescriptor.Builder {
                if tripBuilder_ == nil {
                    tripBuilder_ = TransitRealtime.TripDescriptor.Builder()
                    builderResult.trip = tripBuilder_.getMessage()
                    if trip != nil {
                        try! tripBuilder_.mergeFrom(other: trip)
                    }
                }
                return tripBuilder_
            }
            @discardableResult
            public func setTrip(_ value:TransitRealtime.TripDescriptor!) -> TransitRealtime.VehiclePosition.Builder {
                self.trip = value
                return self
            }
            @discardableResult
            public func mergeTrip(value:TransitRealtime.TripDescriptor) throws -> TransitRealtime.VehiclePosition.Builder {
                if builderResult.hasTrip {
                    builderResult.trip = try TransitRealtime.TripDescriptor.builderWithPrototype(prototype:builderResult.trip).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.trip = value
                }
                builderResult.hasTrip = true
                return self
            }
            @discardableResult
            public func clearTrip() -> TransitRealtime.VehiclePosition.Builder {
                tripBuilder_ = nil
                builderResult.hasTrip = false
                builderResult.trip = nil
                return self
            }
            /// Additional information on the vehicle that is serving this trip.
            public var vehicle:TransitRealtime.VehicleDescriptor! {
                get {
                    if vehicleBuilder_ != nil {
                        builderResult.vehicle = vehicleBuilder_.getMessage()
                    }
                    return builderResult.vehicle
                }
                set (value) {
                    builderResult.hasVehicle = true
                    builderResult.vehicle = value
                }
            }
            public var hasVehicle:Bool {
                get {
                    return builderResult.hasVehicle
                }
            }
            fileprivate var vehicleBuilder_:TransitRealtime.VehicleDescriptor.Builder! {
                didSet {
                    builderResult.hasVehicle = true
                }
            }
            public func getVehicleBuilder() -> TransitRealtime.VehicleDescriptor.Builder {
                if vehicleBuilder_ == nil {
                    vehicleBuilder_ = TransitRealtime.VehicleDescriptor.Builder()
                    builderResult.vehicle = vehicleBuilder_.getMessage()
                    if vehicle != nil {
                        try! vehicleBuilder_.mergeFrom(other: vehicle)
                    }
                }
                return vehicleBuilder_
            }
            @discardableResult
            public func setVehicle(_ value:TransitRealtime.VehicleDescriptor!) -> TransitRealtime.VehiclePosition.Builder {
                self.vehicle = value
                return self
            }
            @discardableResult
            public func mergeVehicle(value:TransitRealtime.VehicleDescriptor) throws -> TransitRealtime.VehiclePosition.Builder {
                if builderResult.hasVehicle {
                    builderResult.vehicle = try TransitRealtime.VehicleDescriptor.builderWithPrototype(prototype:builderResult.vehicle).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.vehicle = value
                }
                builderResult.hasVehicle = true
                return self
            }
            @discardableResult
            public func clearVehicle() -> TransitRealtime.VehiclePosition.Builder {
                vehicleBuilder_ = nil
                builderResult.hasVehicle = false
                builderResult.vehicle = nil
                return self
            }
            /// Current position of this vehicle.
            public var position:TransitRealtime.Position! {
                get {
                    if positionBuilder_ != nil {
                        builderResult.position = positionBuilder_.getMessage()
                    }
                    return builderResult.position
                }
                set (value) {
                    builderResult.hasPosition = true
                    builderResult.position = value
                }
            }
            public var hasPosition:Bool {
                get {
                    return builderResult.hasPosition
                }
            }
            fileprivate var positionBuilder_:TransitRealtime.Position.Builder! {
                didSet {
                    builderResult.hasPosition = true
                }
            }
            public func getPositionBuilder() -> TransitRealtime.Position.Builder {
                if positionBuilder_ == nil {
                    positionBuilder_ = TransitRealtime.Position.Builder()
                    builderResult.position = positionBuilder_.getMessage()
                    if position != nil {
                        try! positionBuilder_.mergeFrom(other: position)
                    }
                }
                return positionBuilder_
            }
            @discardableResult
            public func setPosition(_ value:TransitRealtime.Position!) -> TransitRealtime.VehiclePosition.Builder {
                self.position = value
                return self
            }
            @discardableResult
            public func mergePosition(value:TransitRealtime.Position) throws -> TransitRealtime.VehiclePosition.Builder {
                if builderResult.hasPosition {
                    builderResult.position = try TransitRealtime.Position.builderWithPrototype(prototype:builderResult.position).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.position = value
                }
                builderResult.hasPosition = true
                return self
            }
            @discardableResult
            public func clearPosition() -> TransitRealtime.VehiclePosition.Builder {
                positionBuilder_ = nil
                builderResult.hasPosition = false
                builderResult.position = nil
                return self
            }
            /// The stop sequence index of the current stop. The meaning of
            /// current_stop_sequence (i.e., the stop that it refers to) is determined by
            /// current_status.
            /// If current_status is missing IN_TRANSIT_TO is assumed.
            public var currentStopSequence:UInt32 {
                get {
                    return builderResult.currentStopSequence
                }
                set (value) {
                    builderResult.hasCurrentStopSequence = true
                    builderResult.currentStopSequence = value
                }
            }
            public var hasCurrentStopSequence:Bool {
                get {
                    return builderResult.hasCurrentStopSequence
                }
            }
            @discardableResult
            public func setCurrentStopSequence(_ value:UInt32) -> TransitRealtime.VehiclePosition.Builder {
                self.currentStopSequence = value
                return self
            }
            @discardableResult
            public func clearCurrentStopSequence() -> TransitRealtime.VehiclePosition.Builder{
                builderResult.hasCurrentStopSequence = false
                builderResult.currentStopSequence = UInt32(0)
                return self
            }
            /// Identifies the current stop. The value must be the same as in stops.txt in
            /// the corresponding GTFS feed.
            public var stopId:String {
                get {
                    return builderResult.stopId
                }
                set (value) {
                    builderResult.hasStopId = true
                    builderResult.stopId = value
                }
            }
            public var hasStopId:Bool {
                get {
                    return builderResult.hasStopId
                }
            }
            @discardableResult
            public func setStopId(_ value:String) -> TransitRealtime.VehiclePosition.Builder {
                self.stopId = value
                return self
            }
            @discardableResult
            public func clearStopId() -> TransitRealtime.VehiclePosition.Builder{
                builderResult.hasStopId = false
                builderResult.stopId = ""
                return self
            }
            /// The exact status of the vehicle with respect to the current stop.
            /// Ignored if current_stop_sequence is missing.
                public var currentStatus:TransitRealtime.VehiclePosition.VehicleStopStatus {
                    get {
                        return builderResult.currentStatus
                    }
                    set (value) {
                        builderResult.hasCurrentStatus = true
                        builderResult.currentStatus = value
                    }
                }
                public var hasCurrentStatus:Bool{
                    get {
                        return builderResult.hasCurrentStatus
                    }
                }
            @discardableResult
                public func setCurrentStatus(_ value:TransitRealtime.VehiclePosition.VehicleStopStatus) -> TransitRealtime.VehiclePosition.Builder {
                  self.currentStatus = value
                  return self
                }
            @discardableResult
                public func clearCurrentStatus() -> TransitRealtime.VehiclePosition.Builder {
                   builderResult.hasCurrentStatus = false
                   builderResult.currentStatus = .inTransitTo
                   return self
                }
            /// Moment at which the vehicle's position was measured. In POSIX time
            /// (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
            public var timestamp:UInt64 {
                get {
                    return builderResult.timestamp
                }
                set (value) {
                    builderResult.hasTimestamp = true
                    builderResult.timestamp = value
                }
            }
            public var hasTimestamp:Bool {
                get {
                    return builderResult.hasTimestamp
                }
            }
            @discardableResult
            public func setTimestamp(_ value:UInt64) -> TransitRealtime.VehiclePosition.Builder {
                self.timestamp = value
                return self
            }
            @discardableResult
            public func clearTimestamp() -> TransitRealtime.VehiclePosition.Builder{
                builderResult.hasTimestamp = false
                builderResult.timestamp = UInt64(0)
                return self
            }
                public var congestionLevel:TransitRealtime.VehiclePosition.CongestionLevel {
                    get {
                        return builderResult.congestionLevel
                    }
                    set (value) {
                        builderResult.hasCongestionLevel = true
                        builderResult.congestionLevel = value
                    }
                }
                public var hasCongestionLevel:Bool{
                    get {
                        return builderResult.hasCongestionLevel
                    }
                }
            @discardableResult
                public func setCongestionLevel(_ value:TransitRealtime.VehiclePosition.CongestionLevel) -> TransitRealtime.VehiclePosition.Builder {
                  self.congestionLevel = value
                  return self
                }
            @discardableResult
                public func clearCongestionLevel() -> TransitRealtime.VehiclePosition.Builder {
                   builderResult.hasCongestionLevel = false
                   builderResult.congestionLevel = .unknownCongestionLevel
                   return self
                }
                public var occupancyStatus:TransitRealtime.VehiclePosition.OccupancyStatus {
                    get {
                        return builderResult.occupancyStatus
                    }
                    set (value) {
                        builderResult.hasOccupancyStatus = true
                        builderResult.occupancyStatus = value
                    }
                }
                public var hasOccupancyStatus:Bool{
                    get {
                        return builderResult.hasOccupancyStatus
                    }
                }
            @discardableResult
                public func setOccupancyStatus(_ value:TransitRealtime.VehiclePosition.OccupancyStatus) -> TransitRealtime.VehiclePosition.Builder {
                  self.occupancyStatus = value
                  return self
                }
            @discardableResult
                public func clearOccupancyStatus() -> TransitRealtime.VehiclePosition.Builder {
                   builderResult.hasOccupancyStatus = false
                   builderResult.occupancyStatus = .empty
                   return self
                }
            override public var internalGetResult:ExtendableMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> TransitRealtime.VehiclePosition.Builder {
                builderResult = TransitRealtime.VehiclePosition()
                return self
            }
            override public func clone() throws -> TransitRealtime.VehiclePosition.Builder {
                return try TransitRealtime.VehiclePosition.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> TransitRealtime.VehiclePosition {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> TransitRealtime.VehiclePosition {
                let returnMe:TransitRealtime.VehiclePosition = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:TransitRealtime.VehiclePosition) throws -> TransitRealtime.VehiclePosition.Builder {
                if other == TransitRealtime.VehiclePosition() {
                    return self
                }
                if (other.hasTrip) {
                    try mergeTrip(value: other.trip)
                }
                if (other.hasVehicle) {
                    try mergeVehicle(value: other.vehicle)
                }
                if (other.hasPosition) {
                    try mergePosition(value: other.position)
                }
                if other.hasCurrentStopSequence {
                    currentStopSequence = other.currentStopSequence
                }
                if other.hasStopId {
                    stopId = other.stopId
                }
                if other.hasCurrentStatus {
                    currentStatus = other.currentStatus
                }
                if other.hasTimestamp {
                    timestamp = other.timestamp
                }
                if other.hasCongestionLevel {
                    congestionLevel = other.congestionLevel
                }
                if other.hasOccupancyStatus {
                    occupancyStatus = other.occupancyStatus
                }
                try mergeExtensionFields(other: other)
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.VehiclePosition.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.VehiclePosition.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:TransitRealtime.TripDescriptor.Builder = TransitRealtime.TripDescriptor.Builder()
                        if hasTrip {
                            try subBuilder.mergeFrom(other: trip)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        trip = subBuilder.buildPartial()

                    case 18:
                        let subBuilder:TransitRealtime.Position.Builder = TransitRealtime.Position.Builder()
                        if hasPosition {
                            try subBuilder.mergeFrom(other: position)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        position = subBuilder.buildPartial()

                    case 24:
                        currentStopSequence = try codedInputStream.readUInt32()

                    case 32:
                        let valueIntcurrentStatus = try codedInputStream.readEnum()
                        if let enumscurrentStatus = TransitRealtime.VehiclePosition.VehicleStopStatus(rawValue:valueIntcurrentStatus){
                            currentStatus = enumscurrentStatus
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 4, value:Int64(valueIntcurrentStatus))
                        }

                    case 40:
                        timestamp = try codedInputStream.readUInt64()

                    case 48:
                        let valueIntcongestionLevel = try codedInputStream.readEnum()
                        if let enumscongestionLevel = TransitRealtime.VehiclePosition.CongestionLevel(rawValue:valueIntcongestionLevel){
                            congestionLevel = enumscongestionLevel
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 6, value:Int64(valueIntcongestionLevel))
                        }

                    case 58:
                        stopId = try codedInputStream.readString()

                    case 66:
                        let subBuilder:TransitRealtime.VehicleDescriptor.Builder = TransitRealtime.VehicleDescriptor.Builder()
                        if hasVehicle {
                            try subBuilder.mergeFrom(other: vehicle)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        vehicle = subBuilder.buildPartial()

                    case 72:
                        let valueIntoccupancyStatus = try codedInputStream.readEnum()
                        if let enumsoccupancyStatus = TransitRealtime.VehiclePosition.OccupancyStatus(rawValue:valueIntoccupancyStatus){
                            occupancyStatus = enumsoccupancyStatus
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 9, value:Int64(valueIntoccupancyStatus))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.VehiclePosition.Builder {
                let resultDecodedBuilder = TransitRealtime.VehiclePosition.Builder()
                if let jsonValueTrip = jsonMap["trip"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.trip = try TransitRealtime.TripDescriptor.Builder.decodeToBuilder(jsonMap:jsonValueTrip).build()

                }
                if let jsonValueVehicle = jsonMap["vehicle"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.vehicle = try TransitRealtime.VehicleDescriptor.Builder.decodeToBuilder(jsonMap:jsonValueVehicle).build()

                }
                if let jsonValuePosition = jsonMap["position"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.position = try TransitRealtime.Position.Builder.decodeToBuilder(jsonMap:jsonValuePosition).build()

                }
                if let jsonValueCurrentStopSequence = jsonMap["currentStopSequence"] as? UInt {
                    resultDecodedBuilder.currentStopSequence = UInt32(jsonValueCurrentStopSequence)
                } else if let jsonValueCurrentStopSequence = jsonMap["currentStopSequence"] as? String {
                    resultDecodedBuilder.currentStopSequence = UInt32(jsonValueCurrentStopSequence)!
                }
                if let jsonValueStopId = jsonMap["stopId"] as? String {
                    resultDecodedBuilder.stopId = jsonValueStopId
                }
                if let jsonValueCurrentStatus = jsonMap["currentStatus"] as? String {
                    resultDecodedBuilder.currentStatus = try TransitRealtime.VehiclePosition.VehicleStopStatus.fromString(str: jsonValueCurrentStatus)
                }
                if let jsonValueTimestamp = jsonMap["timestamp"] as? String {
                    resultDecodedBuilder.timestamp = UInt64(jsonValueTimestamp)!
                } else if let jsonValueTimestamp = jsonMap["timestamp"] as? UInt {
                    resultDecodedBuilder.timestamp = UInt64(jsonValueTimestamp)
                }
                if let jsonValueCongestionLevel = jsonMap["congestionLevel"] as? String {
                    resultDecodedBuilder.congestionLevel = try TransitRealtime.VehiclePosition.CongestionLevel.fromString(str: jsonValueCongestionLevel)
                }
                if let jsonValueOccupancyStatus = jsonMap["occupancyStatus"] as? String {
                    resultDecodedBuilder.occupancyStatus = try TransitRealtime.VehiclePosition.OccupancyStatus.fromString(str: jsonValueOccupancyStatus)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> TransitRealtime.VehiclePosition.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try TransitRealtime.VehiclePosition.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// An alert, indicating some sort of incident in the public transit network.
    final public class Alert : ExtendableMessage {

        public static func == (lhs: TransitRealtime.Alert, rhs: TransitRealtime.Alert) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.activePeriod == rhs.activePeriod)
            fieldCheck = fieldCheck && (lhs.informedEntity == rhs.informedEntity)
            fieldCheck = fieldCheck && (lhs.hasCause == rhs.hasCause) && (!lhs.hasCause || lhs.cause == rhs.cause)
            fieldCheck = fieldCheck && (lhs.hasEffect == rhs.hasEffect) && (!lhs.hasEffect || lhs.effect == rhs.effect)
            fieldCheck = fieldCheck && (lhs.hasUrl == rhs.hasUrl) && (!lhs.hasUrl || lhs.url == rhs.url)
            fieldCheck = fieldCheck && (lhs.hasHeaderText == rhs.hasHeaderText) && (!lhs.hasHeaderText || lhs.headerText == rhs.headerText)
            fieldCheck = fieldCheck && (lhs.hasDescriptionText == rhs.hasDescriptionText) && (!lhs.hasDescriptionText || lhs.descriptionText == rhs.descriptionText)
            fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:2000)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



            //Enum type declaration start 

            /// Cause of this alert.
            public enum Cause:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                case unknownCause = 1

                /// Not machine-representable.
                case otherCause = 2
                case technicalProblem = 3

                /// Public transit agency employees stopped working.
                case strike = 4

                /// People are blocking the streets.
                case demonstration = 5
                case accident = 6
                case holiday = 7
                case weather = 8
                case maintenance = 9
                case construction = 10
                case policeActivity = 11
                case medicalEmergency = 12
                public func toString() -> String {
                    switch self {
                    case .unknownCause: return "UNKNOWN_CAUSE"
                    case .otherCause: return "OTHER_CAUSE"
                    case .technicalProblem: return "TECHNICAL_PROBLEM"
                    case .strike: return "STRIKE"
                    case .demonstration: return "DEMONSTRATION"
                    case .accident: return "ACCIDENT"
                    case .holiday: return "HOLIDAY"
                    case .weather: return "WEATHER"
                    case .maintenance: return "MAINTENANCE"
                    case .construction: return "CONSTRUCTION"
                    case .policeActivity: return "POLICE_ACTIVITY"
                    case .medicalEmergency: return "MEDICAL_EMERGENCY"
                    }
                }
                public static func fromString(str:String) throws -> TransitRealtime.Alert.Cause {
                    switch str {
                    case "UNKNOWN_CAUSE":    return .unknownCause
                    case "OTHER_CAUSE":    return .otherCause
                    case "TECHNICAL_PROBLEM":    return .technicalProblem
                    case "STRIKE":    return .strike
                    case "DEMONSTRATION":    return .demonstration
                    case "ACCIDENT":    return .accident
                    case "HOLIDAY":    return .holiday
                    case "WEATHER":    return .weather
                    case "MAINTENANCE":    return .maintenance
                    case "CONSTRUCTION":    return .construction
                    case "POLICE_ACTIVITY":    return .policeActivity
                    case "MEDICAL_EMERGENCY":    return .medicalEmergency
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .unknownCause: return ".unknownCause"
                    case .otherCause: return ".otherCause"
                    case .technicalProblem: return ".technicalProblem"
                    case .strike: return ".strike"
                    case .demonstration: return ".demonstration"
                    case .accident: return ".accident"
                    case .holiday: return ".holiday"
                    case .weather: return ".weather"
                    case .maintenance: return ".maintenance"
                    case .construction: return ".construction"
                    case .policeActivity: return ".policeActivity"
                    case .medicalEmergency: return ".medicalEmergency"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:Cause, rhs:Cause) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 



            //Enum type declaration start 

            /// What is the effect of this problem on the affected entity.
            public enum Effect:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                case noService = 1
                case reducedService = 2

                /// We don't care about INsignificant delays: they are hard to detect, have
                /// little impact on the user, and would clutter the results as they are too
                /// frequent.
                case significantDelays = 3
                case detour = 4
                case additionalService = 5
                case modifiedService = 6
                case otherEffect = 7
                case unknownEffect = 8
                case stopMoved = 9
                public func toString() -> String {
                    switch self {
                    case .noService: return "NO_SERVICE"
                    case .reducedService: return "REDUCED_SERVICE"
                    case .significantDelays: return "SIGNIFICANT_DELAYS"
                    case .detour: return "DETOUR"
                    case .additionalService: return "ADDITIONAL_SERVICE"
                    case .modifiedService: return "MODIFIED_SERVICE"
                    case .otherEffect: return "OTHER_EFFECT"
                    case .unknownEffect: return "UNKNOWN_EFFECT"
                    case .stopMoved: return "STOP_MOVED"
                    }
                }
                public static func fromString(str:String) throws -> TransitRealtime.Alert.Effect {
                    switch str {
                    case "NO_SERVICE":    return .noService
                    case "REDUCED_SERVICE":    return .reducedService
                    case "SIGNIFICANT_DELAYS":    return .significantDelays
                    case "DETOUR":    return .detour
                    case "ADDITIONAL_SERVICE":    return .additionalService
                    case "MODIFIED_SERVICE":    return .modifiedService
                    case "OTHER_EFFECT":    return .otherEffect
                    case "UNKNOWN_EFFECT":    return .unknownEffect
                    case "STOP_MOVED":    return .stopMoved
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .noService: return ".noService"
                    case .reducedService: return ".reducedService"
                    case .significantDelays: return ".significantDelays"
                    case .detour: return ".detour"
                    case .additionalService: return ".additionalService"
                    case .modifiedService: return ".modifiedService"
                    case .otherEffect: return ".otherEffect"
                    case .unknownEffect: return ".unknownEffect"
                    case .stopMoved: return ".stopMoved"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:Effect, rhs:Effect) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        public fileprivate(set) var activePeriod:Array<TransitRealtime.TimeRange>  = Array<TransitRealtime.TimeRange>()
        public fileprivate(set) var informedEntity:Array<TransitRealtime.EntitySelector>  = Array<TransitRealtime.EntitySelector>()
        public fileprivate(set) var cause:TransitRealtime.Alert.Cause = TransitRealtime.Alert.Cause.unknownCause
        public fileprivate(set) var hasCause:Bool = false
        public fileprivate(set) var effect:TransitRealtime.Alert.Effect = TransitRealtime.Alert.Effect.unknownEffect
        public fileprivate(set) var hasEffect:Bool = false
        public fileprivate(set) var url:TransitRealtime.TranslatedString!
        public fileprivate(set) var hasUrl:Bool = false
        public fileprivate(set) var headerText:TransitRealtime.TranslatedString!
        public fileprivate(set) var hasHeaderText:Bool = false
        public fileprivate(set) var descriptionText:TransitRealtime.TranslatedString!
        public fileprivate(set) var hasDescriptionText:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitActivePeriod:Bool = true
            for oneElementActivePeriod in activePeriod {
                if !oneElementActivePeriod.isInitialized() {
                    isInitActivePeriod = false
                    break 
                }
            }
            if !isInitActivePeriod {
                return isInitActivePeriod
            }
            var isInitInformedEntity:Bool = true
            for oneElementInformedEntity in informedEntity {
                if !oneElementInformedEntity.isInitialized() {
                    isInitInformedEntity = false
                    break 
                }
            }
            if !isInitInformedEntity {
                return isInitInformedEntity
            }
            if hasUrl {
                if !url.isInitialized() {
                    return false
                }
            }
            if hasHeaderText {
                if !headerText.isInitialized() {
                    return false
                }
            }
            if hasDescriptionText {
                if !descriptionText.isInitialized() {
                    return false
                }
            }
            if !extensionsAreInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementActivePeriod in activePeriod {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementActivePeriod)
            }
            for oneElementInformedEntity in informedEntity {
                  try codedOutputStream.writeMessage(fieldNumber: 5, value:oneElementInformedEntity)
            }
            if hasCause {
                try codedOutputStream.writeEnum(fieldNumber: 6, value:cause.rawValue)
            }
            if hasEffect {
                try codedOutputStream.writeEnum(fieldNumber: 7, value:effect.rawValue)
            }
            if hasUrl {
                try codedOutputStream.writeMessage(fieldNumber: 8, value:url)
            }
            if hasHeaderText {
                try codedOutputStream.writeMessage(fieldNumber: 10, value:headerText)
            }
            if hasDescriptionText {
                try codedOutputStream.writeMessage(fieldNumber: 11, value:descriptionText)
            }
            try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:2000)
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementActivePeriod in activePeriod {
                serialize_size += oneElementActivePeriod.computeMessageSize(fieldNumber: 1)
            }
            for oneElementInformedEntity in informedEntity {
                serialize_size += oneElementInformedEntity.computeMessageSize(fieldNumber: 5)
            }
            if (hasCause) {
                serialize_size += cause.rawValue.computeEnumSize(fieldNumber: 6)
            }
            if (hasEffect) {
                serialize_size += effect.rawValue.computeEnumSize(fieldNumber: 7)
            }
            if hasUrl {
                if let varSizeurl = url?.computeMessageSize(fieldNumber: 8) {
                    serialize_size += varSizeurl
                }
            }
            if hasHeaderText {
                if let varSizeheaderText = headerText?.computeMessageSize(fieldNumber: 10) {
                    serialize_size += varSizeheaderText
                }
            }
            if hasDescriptionText {
                if let varSizedescriptionText = descriptionText?.computeMessageSize(fieldNumber: 11) {
                    serialize_size += varSizedescriptionText
                }
            }
            serialize_size += extensionsSerializedSize()
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> TransitRealtime.Alert.Builder {
            return TransitRealtime.Alert.classBuilder() as! TransitRealtime.Alert.Builder
        }
        public func getBuilder() -> TransitRealtime.Alert.Builder {
            return classBuilder() as! TransitRealtime.Alert.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.Alert.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.Alert.Builder()
        }
        public func toBuilder() throws -> TransitRealtime.Alert.Builder {
            return try TransitRealtime.Alert.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:TransitRealtime.Alert) throws -> TransitRealtime.Alert.Builder {
            return try TransitRealtime.Alert.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !activePeriod.isEmpty {
                var jsonArrayActivePeriod:Array<Dictionary<String,Any>> = []
                for oneValueActivePeriod in activePeriod {
                    let ecodedMessageActivePeriod = try oneValueActivePeriod.encode()
                    jsonArrayActivePeriod.append(ecodedMessageActivePeriod)
                }
                jsonMap["activePeriod"] = jsonArrayActivePeriod
            }
            if !informedEntity.isEmpty {
                var jsonArrayInformedEntity:Array<Dictionary<String,Any>> = []
                for oneValueInformedEntity in informedEntity {
                    let ecodedMessageInformedEntity = try oneValueInformedEntity.encode()
                    jsonArrayInformedEntity.append(ecodedMessageInformedEntity)
                }
                jsonMap["informedEntity"] = jsonArrayInformedEntity
            }
            if hasCause {
                jsonMap["cause"] = cause.toString()
            }
            if hasEffect {
                jsonMap["effect"] = effect.toString()
            }
            if hasUrl {
                jsonMap["url"] = try url.encode()
            }
            if hasHeaderText {
                jsonMap["headerText"] = try headerText.encode()
            }
            if hasDescriptionText {
                jsonMap["descriptionText"] = try descriptionText.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.Alert {
            return try TransitRealtime.Alert.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> TransitRealtime.Alert {
            return try TransitRealtime.Alert.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var activePeriodElementIndex:Int = 0
            for oneElementActivePeriod in activePeriod {
                output += "\(indent) activePeriod[\(activePeriodElementIndex)] {\n"
                output += try oneElementActivePeriod.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                activePeriodElementIndex += 1
            }
            var informedEntityElementIndex:Int = 0
            for oneElementInformedEntity in informedEntity {
                output += "\(indent) informedEntity[\(informedEntityElementIndex)] {\n"
                output += try oneElementInformedEntity.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                informedEntityElementIndex += 1
            }
            if (hasCause) {
                output += "\(indent) cause: \(cause.description)\n"
            }
            if (hasEffect) {
                output += "\(indent) effect: \(effect.description)\n"
            }
            if hasUrl {
                output += "\(indent) url {\n"
                if let outDescUrl = url {
                    output += try outDescUrl.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasHeaderText {
                output += "\(indent) headerText {\n"
                if let outDescHeaderText = headerText {
                    output += try outDescHeaderText.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasDescriptionText {
                output += "\(indent) descriptionText {\n"
                if let outDescDescriptionText = descriptionText {
                    output += try outDescDescriptionText.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += try getExtensionDescription(startInclusive:1000, endExclusive:2000, indent:indent)
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementActivePeriod in activePeriod {
                    hashCode = (hashCode &* 31) &+ oneElementActivePeriod.hashValue
                }
                for oneElementInformedEntity in informedEntity {
                    hashCode = (hashCode &* 31) &+ oneElementInformedEntity.hashValue
                }
                if hasCause {
                     hashCode = (hashCode &* 31) &+ cause.hashValue
                }
                if hasEffect {
                     hashCode = (hashCode &* 31) &+ effect.hashValue
                }
                if hasUrl {
                    if let hashValueurl = url?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueurl
                    }
                }
                if hasHeaderText {
                    if let hashValueheaderText = headerText?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueheaderText
                    }
                }
                if hasDescriptionText {
                    if let hashValuedescriptionText = descriptionText?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuedescriptionText
                    }
                }
                hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:2000))
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "TransitRealtime.Alert"
        }
        override public func className() -> String {
            return "TransitRealtime.Alert"
        }
        //Meta information declaration end

        final public class Builder : ExtendableMessageBuilder {
            fileprivate var builderResult:TransitRealtime.Alert = TransitRealtime.Alert()
            public func getMessage() -> TransitRealtime.Alert {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Time when the alert should be shown to the user. If missing, the
            /// alert will be shown as long as it appears in the feed.
            /// If multiple ranges are given, the alert will be shown during all of them.
            public var activePeriod:Array<TransitRealtime.TimeRange> {
                get {
                    return builderResult.activePeriod
                }
                set (value) {
                    builderResult.activePeriod = value
                }
            }
            @discardableResult
            public func setActivePeriod(_ value:Array<TransitRealtime.TimeRange>) -> TransitRealtime.Alert.Builder {
                self.activePeriod = value
                return self
            }
            @discardableResult
            public func clearActivePeriod() -> TransitRealtime.Alert.Builder {
                builderResult.activePeriod.removeAll(keepingCapacity: false)
                return self
            }
            /// Entities whose users we should notify of this alert.
            public var informedEntity:Array<TransitRealtime.EntitySelector> {
                get {
                    return builderResult.informedEntity
                }
                set (value) {
                    builderResult.informedEntity = value
                }
            }
            @discardableResult
            public func setInformedEntity(_ value:Array<TransitRealtime.EntitySelector>) -> TransitRealtime.Alert.Builder {
                self.informedEntity = value
                return self
            }
            @discardableResult
            public func clearInformedEntity() -> TransitRealtime.Alert.Builder {
                builderResult.informedEntity.removeAll(keepingCapacity: false)
                return self
            }
                public var cause:TransitRealtime.Alert.Cause {
                    get {
                        return builderResult.cause
                    }
                    set (value) {
                        builderResult.hasCause = true
                        builderResult.cause = value
                    }
                }
                public var hasCause:Bool{
                    get {
                        return builderResult.hasCause
                    }
                }
            @discardableResult
                public func setCause(_ value:TransitRealtime.Alert.Cause) -> TransitRealtime.Alert.Builder {
                  self.cause = value
                  return self
                }
            @discardableResult
                public func clearCause() -> TransitRealtime.Alert.Builder {
                   builderResult.hasCause = false
                   builderResult.cause = .unknownCause
                   return self
                }
                public var effect:TransitRealtime.Alert.Effect {
                    get {
                        return builderResult.effect
                    }
                    set (value) {
                        builderResult.hasEffect = true
                        builderResult.effect = value
                    }
                }
                public var hasEffect:Bool{
                    get {
                        return builderResult.hasEffect
                    }
                }
            @discardableResult
                public func setEffect(_ value:TransitRealtime.Alert.Effect) -> TransitRealtime.Alert.Builder {
                  self.effect = value
                  return self
                }
            @discardableResult
                public func clearEffect() -> TransitRealtime.Alert.Builder {
                   builderResult.hasEffect = false
                   builderResult.effect = .unknownEffect
                   return self
                }
            /// The URL which provides additional information about the alert.
            public var url:TransitRealtime.TranslatedString! {
                get {
                    if urlBuilder_ != nil {
                        builderResult.url = urlBuilder_.getMessage()
                    }
                    return builderResult.url
                }
                set (value) {
                    builderResult.hasUrl = true
                    builderResult.url = value
                }
            }
            public var hasUrl:Bool {
                get {
                    return builderResult.hasUrl
                }
            }
            fileprivate var urlBuilder_:TransitRealtime.TranslatedString.Builder! {
                didSet {
                    builderResult.hasUrl = true
                }
            }
            public func getUrlBuilder() -> TransitRealtime.TranslatedString.Builder {
                if urlBuilder_ == nil {
                    urlBuilder_ = TransitRealtime.TranslatedString.Builder()
                    builderResult.url = urlBuilder_.getMessage()
                    if url != nil {
                        try! urlBuilder_.mergeFrom(other: url)
                    }
                }
                return urlBuilder_
            }
            @discardableResult
            public func setUrl(_ value:TransitRealtime.TranslatedString!) -> TransitRealtime.Alert.Builder {
                self.url = value
                return self
            }
            @discardableResult
            public func mergeUrl(value:TransitRealtime.TranslatedString) throws -> TransitRealtime.Alert.Builder {
                if builderResult.hasUrl {
                    builderResult.url = try TransitRealtime.TranslatedString.builderWithPrototype(prototype:builderResult.url).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.url = value
                }
                builderResult.hasUrl = true
                return self
            }
            @discardableResult
            public func clearUrl() -> TransitRealtime.Alert.Builder {
                urlBuilder_ = nil
                builderResult.hasUrl = false
                builderResult.url = nil
                return self
            }
            /// Alert header. Contains a short summary of the alert text as plain-text.
            public var headerText:TransitRealtime.TranslatedString! {
                get {
                    if headerTextBuilder_ != nil {
                        builderResult.headerText = headerTextBuilder_.getMessage()
                    }
                    return builderResult.headerText
                }
                set (value) {
                    builderResult.hasHeaderText = true
                    builderResult.headerText = value
                }
            }
            public var hasHeaderText:Bool {
                get {
                    return builderResult.hasHeaderText
                }
            }
            fileprivate var headerTextBuilder_:TransitRealtime.TranslatedString.Builder! {
                didSet {
                    builderResult.hasHeaderText = true
                }
            }
            public func getHeaderTextBuilder() -> TransitRealtime.TranslatedString.Builder {
                if headerTextBuilder_ == nil {
                    headerTextBuilder_ = TransitRealtime.TranslatedString.Builder()
                    builderResult.headerText = headerTextBuilder_.getMessage()
                    if headerText != nil {
                        try! headerTextBuilder_.mergeFrom(other: headerText)
                    }
                }
                return headerTextBuilder_
            }
            @discardableResult
            public func setHeaderText(_ value:TransitRealtime.TranslatedString!) -> TransitRealtime.Alert.Builder {
                self.headerText = value
                return self
            }
            @discardableResult
            public func mergeHeaderText(value:TransitRealtime.TranslatedString) throws -> TransitRealtime.Alert.Builder {
                if builderResult.hasHeaderText {
                    builderResult.headerText = try TransitRealtime.TranslatedString.builderWithPrototype(prototype:builderResult.headerText).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.headerText = value
                }
                builderResult.hasHeaderText = true
                return self
            }
            @discardableResult
            public func clearHeaderText() -> TransitRealtime.Alert.Builder {
                headerTextBuilder_ = nil
                builderResult.hasHeaderText = false
                builderResult.headerText = nil
                return self
            }
            /// Full description for the alert as plain-text. The information in the
            /// description should add to the information of the header.
            public var descriptionText:TransitRealtime.TranslatedString! {
                get {
                    if descriptionTextBuilder_ != nil {
                        builderResult.descriptionText = descriptionTextBuilder_.getMessage()
                    }
                    return builderResult.descriptionText
                }
                set (value) {
                    builderResult.hasDescriptionText = true
                    builderResult.descriptionText = value
                }
            }
            public var hasDescriptionText:Bool {
                get {
                    return builderResult.hasDescriptionText
                }
            }
            fileprivate var descriptionTextBuilder_:TransitRealtime.TranslatedString.Builder! {
                didSet {
                    builderResult.hasDescriptionText = true
                }
            }
            public func getDescriptionTextBuilder() -> TransitRealtime.TranslatedString.Builder {
                if descriptionTextBuilder_ == nil {
                    descriptionTextBuilder_ = TransitRealtime.TranslatedString.Builder()
                    builderResult.descriptionText = descriptionTextBuilder_.getMessage()
                    if descriptionText != nil {
                        try! descriptionTextBuilder_.mergeFrom(other: descriptionText)
                    }
                }
                return descriptionTextBuilder_
            }
            @discardableResult
            public func setDescriptionText(_ value:TransitRealtime.TranslatedString!) -> TransitRealtime.Alert.Builder {
                self.descriptionText = value
                return self
            }
            @discardableResult
            public func mergeDescriptionText(value:TransitRealtime.TranslatedString) throws -> TransitRealtime.Alert.Builder {
                if builderResult.hasDescriptionText {
                    builderResult.descriptionText = try TransitRealtime.TranslatedString.builderWithPrototype(prototype:builderResult.descriptionText).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.descriptionText = value
                }
                builderResult.hasDescriptionText = true
                return self
            }
            @discardableResult
            public func clearDescriptionText() -> TransitRealtime.Alert.Builder {
                descriptionTextBuilder_ = nil
                builderResult.hasDescriptionText = false
                builderResult.descriptionText = nil
                return self
            }
            override public var internalGetResult:ExtendableMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> TransitRealtime.Alert.Builder {
                builderResult = TransitRealtime.Alert()
                return self
            }
            override public func clone() throws -> TransitRealtime.Alert.Builder {
                return try TransitRealtime.Alert.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> TransitRealtime.Alert {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> TransitRealtime.Alert {
                let returnMe:TransitRealtime.Alert = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:TransitRealtime.Alert) throws -> TransitRealtime.Alert.Builder {
                if other == TransitRealtime.Alert() {
                    return self
                }
                if !other.activePeriod.isEmpty  {
                     builderResult.activePeriod += other.activePeriod
                }
                if !other.informedEntity.isEmpty  {
                     builderResult.informedEntity += other.informedEntity
                }
                if other.hasCause {
                    cause = other.cause
                }
                if other.hasEffect {
                    effect = other.effect
                }
                if (other.hasUrl) {
                    try mergeUrl(value: other.url)
                }
                if (other.hasHeaderText) {
                    try mergeHeaderText(value: other.headerText)
                }
                if (other.hasDescriptionText) {
                    try mergeDescriptionText(value: other.descriptionText)
                }
                try mergeExtensionFields(other: other)
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.Alert.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.Alert.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = TransitRealtime.TimeRange.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        activePeriod.append(subBuilder.buildPartial())

                    case 42:
                        let subBuilder = TransitRealtime.EntitySelector.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        informedEntity.append(subBuilder.buildPartial())

                    case 48:
                        let valueIntcause = try codedInputStream.readEnum()
                        if let enumscause = TransitRealtime.Alert.Cause(rawValue:valueIntcause){
                            cause = enumscause
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 6, value:Int64(valueIntcause))
                        }

                    case 56:
                        let valueInteffect = try codedInputStream.readEnum()
                        if let enumseffect = TransitRealtime.Alert.Effect(rawValue:valueInteffect){
                            effect = enumseffect
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 7, value:Int64(valueInteffect))
                        }

                    case 66:
                        let subBuilder:TransitRealtime.TranslatedString.Builder = TransitRealtime.TranslatedString.Builder()
                        if hasUrl {
                            try subBuilder.mergeFrom(other: url)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        url = subBuilder.buildPartial()

                    case 82:
                        let subBuilder:TransitRealtime.TranslatedString.Builder = TransitRealtime.TranslatedString.Builder()
                        if hasHeaderText {
                            try subBuilder.mergeFrom(other: headerText)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        headerText = subBuilder.buildPartial()

                    case 90:
                        let subBuilder:TransitRealtime.TranslatedString.Builder = TransitRealtime.TranslatedString.Builder()
                        if hasDescriptionText {
                            try subBuilder.mergeFrom(other: descriptionText)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        descriptionText = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.Alert.Builder {
                let resultDecodedBuilder = TransitRealtime.Alert.Builder()
                if let jsonValueActivePeriod = jsonMap["activePeriod"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayActivePeriod:Array<TransitRealtime.TimeRange> = []
                    for oneValueActivePeriod in jsonValueActivePeriod {
                        let messageFromStringActivePeriod = try TransitRealtime.TimeRange.Builder.decodeToBuilder(jsonMap:oneValueActivePeriod).build()

                        jsonArrayActivePeriod.append(messageFromStringActivePeriod)
                    }
                    resultDecodedBuilder.activePeriod = jsonArrayActivePeriod
                }
                if let jsonValueInformedEntity = jsonMap["informedEntity"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayInformedEntity:Array<TransitRealtime.EntitySelector> = []
                    for oneValueInformedEntity in jsonValueInformedEntity {
                        let messageFromStringInformedEntity = try TransitRealtime.EntitySelector.Builder.decodeToBuilder(jsonMap:oneValueInformedEntity).build()

                        jsonArrayInformedEntity.append(messageFromStringInformedEntity)
                    }
                    resultDecodedBuilder.informedEntity = jsonArrayInformedEntity
                }
                if let jsonValueCause = jsonMap["cause"] as? String {
                    resultDecodedBuilder.cause = try TransitRealtime.Alert.Cause.fromString(str: jsonValueCause)
                }
                if let jsonValueEffect = jsonMap["effect"] as? String {
                    resultDecodedBuilder.effect = try TransitRealtime.Alert.Effect.fromString(str: jsonValueEffect)
                }
                if let jsonValueUrl = jsonMap["url"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.url = try TransitRealtime.TranslatedString.Builder.decodeToBuilder(jsonMap:jsonValueUrl).build()

                }
                if let jsonValueHeaderText = jsonMap["headerText"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.headerText = try TransitRealtime.TranslatedString.Builder.decodeToBuilder(jsonMap:jsonValueHeaderText).build()

                }
                if let jsonValueDescriptionText = jsonMap["descriptionText"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.descriptionText = try TransitRealtime.TranslatedString.Builder.decodeToBuilder(jsonMap:jsonValueDescriptionText).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> TransitRealtime.Alert.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try TransitRealtime.Alert.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// A time interval. The interval is considered active at time 't' if 't' is
    /// greater than or equal to the start time and less than the end time.
    final public class TimeRange : ExtendableMessage {

        public static func == (lhs: TransitRealtime.TimeRange, rhs: TransitRealtime.TimeRange) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasStart == rhs.hasStart) && (!lhs.hasStart || lhs.start == rhs.start)
            fieldCheck = fieldCheck && (lhs.hasEnd == rhs.hasEnd) && (!lhs.hasEnd || lhs.end == rhs.end)
            fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:2000)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Start time, in POSIX time (i.e., number of seconds since January 1st 1970
        /// 00:00:00 UTC).
        /// If missing, the interval starts at minus infinity.
        public fileprivate(set) var start:UInt64 = UInt64(0)
        public fileprivate(set) var hasStart:Bool = false

        /// End time, in POSIX time (i.e., number of seconds since January 1st 1970
        /// 00:00:00 UTC).
        /// If missing, the interval ends at plus infinity.
        public fileprivate(set) var end:UInt64 = UInt64(0)
        public fileprivate(set) var hasEnd:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !extensionsAreInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasStart {
                try codedOutputStream.writeUInt64(fieldNumber: 1, value:start)
            }
            if hasEnd {
                try codedOutputStream.writeUInt64(fieldNumber: 2, value:end)
            }
            try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:2000)
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasStart {
                serialize_size += start.computeUInt64Size(fieldNumber: 1)
            }
            if hasEnd {
                serialize_size += end.computeUInt64Size(fieldNumber: 2)
            }
            serialize_size += extensionsSerializedSize()
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> TransitRealtime.TimeRange.Builder {
            return TransitRealtime.TimeRange.classBuilder() as! TransitRealtime.TimeRange.Builder
        }
        public func getBuilder() -> TransitRealtime.TimeRange.Builder {
            return classBuilder() as! TransitRealtime.TimeRange.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.TimeRange.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.TimeRange.Builder()
        }
        public func toBuilder() throws -> TransitRealtime.TimeRange.Builder {
            return try TransitRealtime.TimeRange.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:TransitRealtime.TimeRange) throws -> TransitRealtime.TimeRange.Builder {
            return try TransitRealtime.TimeRange.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasStart {
                jsonMap["start"] = "\(start)"
            }
            if hasEnd {
                jsonMap["end"] = "\(end)"
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.TimeRange {
            return try TransitRealtime.TimeRange.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> TransitRealtime.TimeRange {
            return try TransitRealtime.TimeRange.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasStart {
                output += "\(indent) start: \(start) \n"
            }
            if hasEnd {
                output += "\(indent) end: \(end) \n"
            }
            output += try getExtensionDescription(startInclusive:1000, endExclusive:2000, indent:indent)
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasStart {
                    hashCode = (hashCode &* 31) &+ start.hashValue
                }
                if hasEnd {
                    hashCode = (hashCode &* 31) &+ end.hashValue
                }
                hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:2000))
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "TransitRealtime.TimeRange"
        }
        override public func className() -> String {
            return "TransitRealtime.TimeRange"
        }
        //Meta information declaration end

        final public class Builder : ExtendableMessageBuilder {
            fileprivate var builderResult:TransitRealtime.TimeRange = TransitRealtime.TimeRange()
            public func getMessage() -> TransitRealtime.TimeRange {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Start time, in POSIX time (i.e., number of seconds since January 1st 1970
            /// 00:00:00 UTC).
            /// If missing, the interval starts at minus infinity.
            public var start:UInt64 {
                get {
                    return builderResult.start
                }
                set (value) {
                    builderResult.hasStart = true
                    builderResult.start = value
                }
            }
            public var hasStart:Bool {
                get {
                    return builderResult.hasStart
                }
            }
            @discardableResult
            public func setStart(_ value:UInt64) -> TransitRealtime.TimeRange.Builder {
                self.start = value
                return self
            }
            @discardableResult
            public func clearStart() -> TransitRealtime.TimeRange.Builder{
                builderResult.hasStart = false
                builderResult.start = UInt64(0)
                return self
            }
            /// End time, in POSIX time (i.e., number of seconds since January 1st 1970
            /// 00:00:00 UTC).
            /// If missing, the interval ends at plus infinity.
            public var end:UInt64 {
                get {
                    return builderResult.end
                }
                set (value) {
                    builderResult.hasEnd = true
                    builderResult.end = value
                }
            }
            public var hasEnd:Bool {
                get {
                    return builderResult.hasEnd
                }
            }
            @discardableResult
            public func setEnd(_ value:UInt64) -> TransitRealtime.TimeRange.Builder {
                self.end = value
                return self
            }
            @discardableResult
            public func clearEnd() -> TransitRealtime.TimeRange.Builder{
                builderResult.hasEnd = false
                builderResult.end = UInt64(0)
                return self
            }
            override public var internalGetResult:ExtendableMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> TransitRealtime.TimeRange.Builder {
                builderResult = TransitRealtime.TimeRange()
                return self
            }
            override public func clone() throws -> TransitRealtime.TimeRange.Builder {
                return try TransitRealtime.TimeRange.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> TransitRealtime.TimeRange {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> TransitRealtime.TimeRange {
                let returnMe:TransitRealtime.TimeRange = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:TransitRealtime.TimeRange) throws -> TransitRealtime.TimeRange.Builder {
                if other == TransitRealtime.TimeRange() {
                    return self
                }
                if other.hasStart {
                    start = other.start
                }
                if other.hasEnd {
                    end = other.end
                }
                try mergeExtensionFields(other: other)
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.TimeRange.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TimeRange.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        start = try codedInputStream.readUInt64()

                    case 16:
                        end = try codedInputStream.readUInt64()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.TimeRange.Builder {
                let resultDecodedBuilder = TransitRealtime.TimeRange.Builder()
                if let jsonValueStart = jsonMap["start"] as? String {
                    resultDecodedBuilder.start = UInt64(jsonValueStart)!
                } else if let jsonValueStart = jsonMap["start"] as? UInt {
                    resultDecodedBuilder.start = UInt64(jsonValueStart)
                }
                if let jsonValueEnd = jsonMap["end"] as? String {
                    resultDecodedBuilder.end = UInt64(jsonValueEnd)!
                } else if let jsonValueEnd = jsonMap["end"] as? UInt {
                    resultDecodedBuilder.end = UInt64(jsonValueEnd)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> TransitRealtime.TimeRange.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try TransitRealtime.TimeRange.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// A position.
    final public class Position : ExtendableMessage {

        public static func == (lhs: TransitRealtime.Position, rhs: TransitRealtime.Position) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
            fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
            fieldCheck = fieldCheck && (lhs.hasBearing == rhs.hasBearing) && (!lhs.hasBearing || lhs.bearing == rhs.bearing)
            fieldCheck = fieldCheck && (lhs.hasOdometer == rhs.hasOdometer) && (!lhs.hasOdometer || lhs.odometer == rhs.odometer)
            fieldCheck = fieldCheck && (lhs.hasSpeed == rhs.hasSpeed) && (!lhs.hasSpeed || lhs.speed == rhs.speed)
            fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:2000)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Degrees North, in the WGS-84 coordinate system.
        public fileprivate(set) var latitude:Float = Float(0)
        public fileprivate(set) var hasLatitude:Bool = false

        /// Degrees East, in the WGS-84 coordinate system.
        public fileprivate(set) var longitude:Float = Float(0)
        public fileprivate(set) var hasLongitude:Bool = false

        /// Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
        /// This can be the compass bearing, or the direction towards the next stop
        /// or intermediate location.
        /// This should not be direction deduced from the sequence of previous
        /// positions, which can be computed from previous data.
        public fileprivate(set) var bearing:Float = Float(0)
        public fileprivate(set) var hasBearing:Bool = false

        /// Odometer value, in meters.
        public fileprivate(set) var odometer:Double = Double(0)
        public fileprivate(set) var hasOdometer:Bool = false

        /// Momentary speed measured by the vehicle, in meters per second.
        public fileprivate(set) var speed:Float = Float(0)
        public fileprivate(set) var hasSpeed:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasLatitude {
                return false
            }
            if !hasLongitude {
                return false
            }
            if !extensionsAreInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasLatitude {
                try codedOutputStream.writeFloat(fieldNumber: 1, value:latitude)
            }
            if hasLongitude {
                try codedOutputStream.writeFloat(fieldNumber: 2, value:longitude)
            }
            if hasBearing {
                try codedOutputStream.writeFloat(fieldNumber: 3, value:bearing)
            }
            if hasOdometer {
                try codedOutputStream.writeDouble(fieldNumber: 4, value:odometer)
            }
            if hasSpeed {
                try codedOutputStream.writeFloat(fieldNumber: 5, value:speed)
            }
            try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:2000)
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasLatitude {
                serialize_size += latitude.computeFloatSize(fieldNumber: 1)
            }
            if hasLongitude {
                serialize_size += longitude.computeFloatSize(fieldNumber: 2)
            }
            if hasBearing {
                serialize_size += bearing.computeFloatSize(fieldNumber: 3)
            }
            if hasOdometer {
                serialize_size += odometer.computeDoubleSize(fieldNumber: 4)
            }
            if hasSpeed {
                serialize_size += speed.computeFloatSize(fieldNumber: 5)
            }
            serialize_size += extensionsSerializedSize()
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> TransitRealtime.Position.Builder {
            return TransitRealtime.Position.classBuilder() as! TransitRealtime.Position.Builder
        }
        public func getBuilder() -> TransitRealtime.Position.Builder {
            return classBuilder() as! TransitRealtime.Position.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.Position.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.Position.Builder()
        }
        public func toBuilder() throws -> TransitRealtime.Position.Builder {
            return try TransitRealtime.Position.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:TransitRealtime.Position) throws -> TransitRealtime.Position.Builder {
            return try TransitRealtime.Position.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasLatitude {
                jsonMap["latitude"] = Float(latitude)
            }
            if hasLongitude {
                jsonMap["longitude"] = Float(longitude)
            }
            if hasBearing {
                jsonMap["bearing"] = Float(bearing)
            }
            if hasOdometer {
                jsonMap["odometer"] = Double(odometer)
            }
            if hasSpeed {
                jsonMap["speed"] = Float(speed)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.Position {
            return try TransitRealtime.Position.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> TransitRealtime.Position {
            return try TransitRealtime.Position.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasLatitude {
                output += "\(indent) latitude: \(latitude) \n"
            }
            if hasLongitude {
                output += "\(indent) longitude: \(longitude) \n"
            }
            if hasBearing {
                output += "\(indent) bearing: \(bearing) \n"
            }
            if hasOdometer {
                output += "\(indent) odometer: \(odometer) \n"
            }
            if hasSpeed {
                output += "\(indent) speed: \(speed) \n"
            }
            output += try getExtensionDescription(startInclusive:1000, endExclusive:2000, indent:indent)
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasLatitude {
                    hashCode = (hashCode &* 31) &+ latitude.hashValue
                }
                if hasLongitude {
                    hashCode = (hashCode &* 31) &+ longitude.hashValue
                }
                if hasBearing {
                    hashCode = (hashCode &* 31) &+ bearing.hashValue
                }
                if hasOdometer {
                    hashCode = (hashCode &* 31) &+ odometer.hashValue
                }
                if hasSpeed {
                    hashCode = (hashCode &* 31) &+ speed.hashValue
                }
                hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:2000))
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "TransitRealtime.Position"
        }
        override public func className() -> String {
            return "TransitRealtime.Position"
        }
        //Meta information declaration end

        final public class Builder : ExtendableMessageBuilder {
            fileprivate var builderResult:TransitRealtime.Position = TransitRealtime.Position()
            public func getMessage() -> TransitRealtime.Position {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Degrees North, in the WGS-84 coordinate system.
            public var latitude:Float {
                get {
                    return builderResult.latitude
                }
                set (value) {
                    builderResult.hasLatitude = true
                    builderResult.latitude = value
                }
            }
            public var hasLatitude:Bool {
                get {
                    return builderResult.hasLatitude
                }
            }
            @discardableResult
            public func setLatitude(_ value:Float) -> TransitRealtime.Position.Builder {
                self.latitude = value
                return self
            }
            @discardableResult
            public func clearLatitude() -> TransitRealtime.Position.Builder{
                builderResult.hasLatitude = false
                builderResult.latitude = Float(0)
                return self
            }
            /// Degrees East, in the WGS-84 coordinate system.
            public var longitude:Float {
                get {
                    return builderResult.longitude
                }
                set (value) {
                    builderResult.hasLongitude = true
                    builderResult.longitude = value
                }
            }
            public var hasLongitude:Bool {
                get {
                    return builderResult.hasLongitude
                }
            }
            @discardableResult
            public func setLongitude(_ value:Float) -> TransitRealtime.Position.Builder {
                self.longitude = value
                return self
            }
            @discardableResult
            public func clearLongitude() -> TransitRealtime.Position.Builder{
                builderResult.hasLongitude = false
                builderResult.longitude = Float(0)
                return self
            }
            /// Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
            /// This can be the compass bearing, or the direction towards the next stop
            /// or intermediate location.
            /// This should not be direction deduced from the sequence of previous
            /// positions, which can be computed from previous data.
            public var bearing:Float {
                get {
                    return builderResult.bearing
                }
                set (value) {
                    builderResult.hasBearing = true
                    builderResult.bearing = value
                }
            }
            public var hasBearing:Bool {
                get {
                    return builderResult.hasBearing
                }
            }
            @discardableResult
            public func setBearing(_ value:Float) -> TransitRealtime.Position.Builder {
                self.bearing = value
                return self
            }
            @discardableResult
            public func clearBearing() -> TransitRealtime.Position.Builder{
                builderResult.hasBearing = false
                builderResult.bearing = Float(0)
                return self
            }
            /// Odometer value, in meters.
            public var odometer:Double {
                get {
                    return builderResult.odometer
                }
                set (value) {
                    builderResult.hasOdometer = true
                    builderResult.odometer = value
                }
            }
            public var hasOdometer:Bool {
                get {
                    return builderResult.hasOdometer
                }
            }
            @discardableResult
            public func setOdometer(_ value:Double) -> TransitRealtime.Position.Builder {
                self.odometer = value
                return self
            }
            @discardableResult
            public func clearOdometer() -> TransitRealtime.Position.Builder{
                builderResult.hasOdometer = false
                builderResult.odometer = Double(0)
                return self
            }
            /// Momentary speed measured by the vehicle, in meters per second.
            public var speed:Float {
                get {
                    return builderResult.speed
                }
                set (value) {
                    builderResult.hasSpeed = true
                    builderResult.speed = value
                }
            }
            public var hasSpeed:Bool {
                get {
                    return builderResult.hasSpeed
                }
            }
            @discardableResult
            public func setSpeed(_ value:Float) -> TransitRealtime.Position.Builder {
                self.speed = value
                return self
            }
            @discardableResult
            public func clearSpeed() -> TransitRealtime.Position.Builder{
                builderResult.hasSpeed = false
                builderResult.speed = Float(0)
                return self
            }
            override public var internalGetResult:ExtendableMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> TransitRealtime.Position.Builder {
                builderResult = TransitRealtime.Position()
                return self
            }
            override public func clone() throws -> TransitRealtime.Position.Builder {
                return try TransitRealtime.Position.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> TransitRealtime.Position {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> TransitRealtime.Position {
                let returnMe:TransitRealtime.Position = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:TransitRealtime.Position) throws -> TransitRealtime.Position.Builder {
                if other == TransitRealtime.Position() {
                    return self
                }
                if other.hasLatitude {
                    latitude = other.latitude
                }
                if other.hasLongitude {
                    longitude = other.longitude
                }
                if other.hasBearing {
                    bearing = other.bearing
                }
                if other.hasOdometer {
                    odometer = other.odometer
                }
                if other.hasSpeed {
                    speed = other.speed
                }
                try mergeExtensionFields(other: other)
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.Position.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.Position.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 13:
                        latitude = try codedInputStream.readFloat()

                    case 21:
                        longitude = try codedInputStream.readFloat()

                    case 29:
                        bearing = try codedInputStream.readFloat()

                    case 33:
                        odometer = try codedInputStream.readDouble()

                    case 45:
                        speed = try codedInputStream.readFloat()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.Position.Builder {
                let resultDecodedBuilder = TransitRealtime.Position.Builder()
                if let jsonValueLatitude = jsonMap["latitude"] as? Float {
                    resultDecodedBuilder.latitude = Float(jsonValueLatitude)
                } else if let jsonValueLatitude = jsonMap["latitude"] as? String {
                    resultDecodedBuilder.latitude = Float(jsonValueLatitude)!
                }
                if let jsonValueLongitude = jsonMap["longitude"] as? Float {
                    resultDecodedBuilder.longitude = Float(jsonValueLongitude)
                } else if let jsonValueLongitude = jsonMap["longitude"] as? String {
                    resultDecodedBuilder.longitude = Float(jsonValueLongitude)!
                }
                if let jsonValueBearing = jsonMap["bearing"] as? Float {
                    resultDecodedBuilder.bearing = Float(jsonValueBearing)
                } else if let jsonValueBearing = jsonMap["bearing"] as? String {
                    resultDecodedBuilder.bearing = Float(jsonValueBearing)!
                }
                if let jsonValueOdometer = jsonMap["odometer"] as? Double {
                    resultDecodedBuilder.odometer = Double(jsonValueOdometer)
                } else if let jsonValueOdometer = jsonMap["odometer"] as? String {
                    resultDecodedBuilder.odometer = Double(jsonValueOdometer)!
                }
                if let jsonValueSpeed = jsonMap["speed"] as? Float {
                    resultDecodedBuilder.speed = Float(jsonValueSpeed)
                } else if let jsonValueSpeed = jsonMap["speed"] as? String {
                    resultDecodedBuilder.speed = Float(jsonValueSpeed)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> TransitRealtime.Position.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try TransitRealtime.Position.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// A descriptor that identifies an instance of a GTFS trip, or all instances of
    /// a trip along a route.
    /// - To specify a single trip instance, the trip_id (and if necessary,
    ///   start_time) is set. If route_id is also set, then it should be same as one
    ///   that the given trip corresponds to.
    /// - To specify all the trips along a given route, only the route_id should be
    ///   set. Note that if the trip_id is not known, then stop sequence ids in
    ///   TripUpdate are not sufficient, and stop_ids must be provided as well. In
    ///   addition, absolute arrival/departure times must be provided.
    final public class TripDescriptor : ExtendableMessage {

        public static func == (lhs: TransitRealtime.TripDescriptor, rhs: TransitRealtime.TripDescriptor) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTripId == rhs.hasTripId) && (!lhs.hasTripId || lhs.tripId == rhs.tripId)
            fieldCheck = fieldCheck && (lhs.hasStartTime == rhs.hasStartTime) && (!lhs.hasStartTime || lhs.startTime == rhs.startTime)
            fieldCheck = fieldCheck && (lhs.hasStartDate == rhs.hasStartDate) && (!lhs.hasStartDate || lhs.startDate == rhs.startDate)
            fieldCheck = fieldCheck && (lhs.hasScheduleRelationship == rhs.hasScheduleRelationship) && (!lhs.hasScheduleRelationship || lhs.scheduleRelationship == rhs.scheduleRelationship)
            fieldCheck = fieldCheck && (lhs.hasRouteId == rhs.hasRouteId) && (!lhs.hasRouteId || lhs.routeId == rhs.routeId)
            fieldCheck = fieldCheck && (lhs.hasDirectionId == rhs.hasDirectionId) && (!lhs.hasDirectionId || lhs.directionId == rhs.directionId)
            fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:2000)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



            //Enum type declaration start 

            /// The relation between this trip and the static schedule. If a trip is done
            /// in accordance with temporary schedule, not reflected in GTFS, then it
            /// shouldn't be marked as SCHEDULED, but likely as ADDED.
            public enum ScheduleRelationship:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
                /// Trip that is running in accordance with its GTFS schedule, or is close
                /// enough to the scheduled trip to be associated with it.
                case scheduled = 0

                /// An extra trip that was added in addition to a running schedule, for
                /// example, to replace a broken vehicle or to respond to sudden passenger
                /// load.
                case added = 1

                /// A trip that is running with no schedule associated to it, for example, if
                /// there is no schedule at all.
                case unscheduled = 2

                /// A trip that existed in the schedule but was removed.
                case canceled = 3
                public func toString() -> String {
                    switch self {
                    case .scheduled: return "SCHEDULED"
                    case .added: return "ADDED"
                    case .unscheduled: return "UNSCHEDULED"
                    case .canceled: return "CANCELED"
                    }
                }
                public static func fromString(str:String) throws -> TransitRealtime.TripDescriptor.ScheduleRelationship {
                    switch str {
                    case "SCHEDULED":    return .scheduled
                    case "ADDED":    return .added
                    case "UNSCHEDULED":    return .unscheduled
                    case "CANCELED":    return .canceled
                    default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
                    }
                }
                public var debugDescription:String { return getDescription() }
                public var description:String { return getDescription() }
                private func getDescription() -> String { 
                    switch self {
                    case .scheduled: return ".scheduled"
                    case .added: return ".added"
                    case .unscheduled: return ".unscheduled"
                    case .canceled: return ".canceled"
                    }
                }
                public var hashValue:Int {
                    return self.rawValue.hashValue
                }
                public static func ==(lhs:ScheduleRelationship, rhs:ScheduleRelationship) -> Bool {
                    return lhs.hashValue == rhs.hashValue
                }
            }

            //Enum type declaration end 

        /// The trip_id from the GTFS feed that this selector refers to.
        /// For non frequency-based trips, this field is enough to uniquely identify
        /// the trip. For frequency-based trip, start_time and start_date might also be
        /// necessary.
        public fileprivate(set) var tripId:String = ""
        public fileprivate(set) var hasTripId:Bool = false

        /// The route_id from the GTFS that this selector refers to.
        public fileprivate(set) var routeId:String = ""
        public fileprivate(set) var hasRouteId:Bool = false

        /// The direction_id from the GTFS feed trips.txt file, indicating the
        /// direction of travel for trips this selector refers to. This field is
        /// still experimental, and subject to change. It may be formally adopted in
        /// the future.
        public fileprivate(set) var directionId:UInt32 = UInt32(0)
        public fileprivate(set) var hasDirectionId:Bool = false

        /// The initially scheduled start time of this trip instance.
        /// When the trip_id corresponds to a non-frequency-based trip, this field
        /// should either be omitted or be equal to the value in the GTFS feed. When
        /// the trip_id correponds to a frequency-based trip, the start_time must be
        /// specified for trip updates and vehicle positions. If the trip corresponds
        /// to exact_times=1 GTFS record, then start_time must be some multiple
        /// (including zero) of headway_secs later than frequencies.txt start_time for
        /// the corresponding time period. If the trip corresponds to exact_times=0,
        /// then its start_time may be arbitrary, and is initially expected to be the
        /// first departure of the trip. Once established, the start_time of this
        /// frequency-based trip should be considered immutable, even if the first
        /// departure time changes -- that time change may instead be reflected in a
        /// StopTimeUpdate.
        /// Format and semantics of the field is same as that of
        /// GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
        public fileprivate(set) var startTime:String = ""
        public fileprivate(set) var hasStartTime:Bool = false

        /// The scheduled start date of this trip instance.
        /// Must be provided to disambiguate trips that are so late as to collide with
        /// a scheduled trip on a next day. For example, for a train that departs 8:00
        /// and 20:00 every day, and is 12 hours late, there would be two distinct
        /// trips on the same time.
        /// This field can be provided but is not mandatory for schedules in which such
        /// collisions are impossible - for example, a service running on hourly
        /// schedule where a vehicle that is one hour late is not considered to be
        /// related to schedule anymore.
        /// In YYYYMMDD format.
        public fileprivate(set) var startDate:String = ""
        public fileprivate(set) var hasStartDate:Bool = false

        public fileprivate(set) var scheduleRelationship:TransitRealtime.TripDescriptor.ScheduleRelationship = TransitRealtime.TripDescriptor.ScheduleRelationship.scheduled
        public fileprivate(set) var hasScheduleRelationship:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !extensionsAreInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTripId {
                try codedOutputStream.writeString(fieldNumber: 1, value:tripId)
            }
            if hasStartTime {
                try codedOutputStream.writeString(fieldNumber: 2, value:startTime)
            }
            if hasStartDate {
                try codedOutputStream.writeString(fieldNumber: 3, value:startDate)
            }
            if hasScheduleRelationship {
                try codedOutputStream.writeEnum(fieldNumber: 4, value:scheduleRelationship.rawValue)
            }
            if hasRouteId {
                try codedOutputStream.writeString(fieldNumber: 5, value:routeId)
            }
            if hasDirectionId {
                try codedOutputStream.writeUInt32(fieldNumber: 6, value:directionId)
            }
            try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:2000)
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTripId {
                serialize_size += tripId.computeStringSize(fieldNumber: 1)
            }
            if hasStartTime {
                serialize_size += startTime.computeStringSize(fieldNumber: 2)
            }
            if hasStartDate {
                serialize_size += startDate.computeStringSize(fieldNumber: 3)
            }
            if (hasScheduleRelationship) {
                serialize_size += scheduleRelationship.rawValue.computeEnumSize(fieldNumber: 4)
            }
            if hasRouteId {
                serialize_size += routeId.computeStringSize(fieldNumber: 5)
            }
            if hasDirectionId {
                serialize_size += directionId.computeUInt32Size(fieldNumber: 6)
            }
            serialize_size += extensionsSerializedSize()
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> TransitRealtime.TripDescriptor.Builder {
            return TransitRealtime.TripDescriptor.classBuilder() as! TransitRealtime.TripDescriptor.Builder
        }
        public func getBuilder() -> TransitRealtime.TripDescriptor.Builder {
            return classBuilder() as! TransitRealtime.TripDescriptor.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.TripDescriptor.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.TripDescriptor.Builder()
        }
        public func toBuilder() throws -> TransitRealtime.TripDescriptor.Builder {
            return try TransitRealtime.TripDescriptor.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:TransitRealtime.TripDescriptor) throws -> TransitRealtime.TripDescriptor.Builder {
            return try TransitRealtime.TripDescriptor.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTripId {
                jsonMap["tripId"] = tripId
            }
            if hasRouteId {
                jsonMap["routeId"] = routeId
            }
            if hasDirectionId {
                jsonMap["directionId"] = UInt(directionId)
            }
            if hasStartTime {
                jsonMap["startTime"] = startTime
            }
            if hasStartDate {
                jsonMap["startDate"] = startDate
            }
            if hasScheduleRelationship {
                jsonMap["scheduleRelationship"] = scheduleRelationship.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.TripDescriptor {
            return try TransitRealtime.TripDescriptor.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> TransitRealtime.TripDescriptor {
            return try TransitRealtime.TripDescriptor.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTripId {
                output += "\(indent) tripId: \(tripId) \n"
            }
            if hasStartTime {
                output += "\(indent) startTime: \(startTime) \n"
            }
            if hasStartDate {
                output += "\(indent) startDate: \(startDate) \n"
            }
            if (hasScheduleRelationship) {
                output += "\(indent) scheduleRelationship: \(scheduleRelationship.description)\n"
            }
            if hasRouteId {
                output += "\(indent) routeId: \(routeId) \n"
            }
            if hasDirectionId {
                output += "\(indent) directionId: \(directionId) \n"
            }
            output += try getExtensionDescription(startInclusive:1000, endExclusive:2000, indent:indent)
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTripId {
                    hashCode = (hashCode &* 31) &+ tripId.hashValue
                }
                if hasStartTime {
                    hashCode = (hashCode &* 31) &+ startTime.hashValue
                }
                if hasStartDate {
                    hashCode = (hashCode &* 31) &+ startDate.hashValue
                }
                if hasScheduleRelationship {
                     hashCode = (hashCode &* 31) &+ scheduleRelationship.hashValue
                }
                if hasRouteId {
                    hashCode = (hashCode &* 31) &+ routeId.hashValue
                }
                if hasDirectionId {
                    hashCode = (hashCode &* 31) &+ directionId.hashValue
                }
                hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:2000))
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "TransitRealtime.TripDescriptor"
        }
        override public func className() -> String {
            return "TransitRealtime.TripDescriptor"
        }
        //Meta information declaration end

        final public class Builder : ExtendableMessageBuilder {
            fileprivate var builderResult:TransitRealtime.TripDescriptor = TransitRealtime.TripDescriptor()
            public func getMessage() -> TransitRealtime.TripDescriptor {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The trip_id from the GTFS feed that this selector refers to.
            /// For non frequency-based trips, this field is enough to uniquely identify
            /// the trip. For frequency-based trip, start_time and start_date might also be
            /// necessary.
            public var tripId:String {
                get {
                    return builderResult.tripId
                }
                set (value) {
                    builderResult.hasTripId = true
                    builderResult.tripId = value
                }
            }
            public var hasTripId:Bool {
                get {
                    return builderResult.hasTripId
                }
            }
            @discardableResult
            public func setTripId(_ value:String) -> TransitRealtime.TripDescriptor.Builder {
                self.tripId = value
                return self
            }
            @discardableResult
            public func clearTripId() -> TransitRealtime.TripDescriptor.Builder{
                builderResult.hasTripId = false
                builderResult.tripId = ""
                return self
            }
            /// The route_id from the GTFS that this selector refers to.
            public var routeId:String {
                get {
                    return builderResult.routeId
                }
                set (value) {
                    builderResult.hasRouteId = true
                    builderResult.routeId = value
                }
            }
            public var hasRouteId:Bool {
                get {
                    return builderResult.hasRouteId
                }
            }
            @discardableResult
            public func setRouteId(_ value:String) -> TransitRealtime.TripDescriptor.Builder {
                self.routeId = value
                return self
            }
            @discardableResult
            public func clearRouteId() -> TransitRealtime.TripDescriptor.Builder{
                builderResult.hasRouteId = false
                builderResult.routeId = ""
                return self
            }
            /// The direction_id from the GTFS feed trips.txt file, indicating the
            /// direction of travel for trips this selector refers to. This field is
            /// still experimental, and subject to change. It may be formally adopted in
            /// the future.
            public var directionId:UInt32 {
                get {
                    return builderResult.directionId
                }
                set (value) {
                    builderResult.hasDirectionId = true
                    builderResult.directionId = value
                }
            }
            public var hasDirectionId:Bool {
                get {
                    return builderResult.hasDirectionId
                }
            }
            @discardableResult
            public func setDirectionId(_ value:UInt32) -> TransitRealtime.TripDescriptor.Builder {
                self.directionId = value
                return self
            }
            @discardableResult
            public func clearDirectionId() -> TransitRealtime.TripDescriptor.Builder{
                builderResult.hasDirectionId = false
                builderResult.directionId = UInt32(0)
                return self
            }
            /// The initially scheduled start time of this trip instance.
            /// When the trip_id corresponds to a non-frequency-based trip, this field
            /// should either be omitted or be equal to the value in the GTFS feed. When
            /// the trip_id correponds to a frequency-based trip, the start_time must be
            /// specified for trip updates and vehicle positions. If the trip corresponds
            /// to exact_times=1 GTFS record, then start_time must be some multiple
            /// (including zero) of headway_secs later than frequencies.txt start_time for
            /// the corresponding time period. If the trip corresponds to exact_times=0,
            /// then its start_time may be arbitrary, and is initially expected to be the
            /// first departure of the trip. Once established, the start_time of this
            /// frequency-based trip should be considered immutable, even if the first
            /// departure time changes -- that time change may instead be reflected in a
            /// StopTimeUpdate.
            /// Format and semantics of the field is same as that of
            /// GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
            public var startTime:String {
                get {
                    return builderResult.startTime
                }
                set (value) {
                    builderResult.hasStartTime = true
                    builderResult.startTime = value
                }
            }
            public var hasStartTime:Bool {
                get {
                    return builderResult.hasStartTime
                }
            }
            @discardableResult
            public func setStartTime(_ value:String) -> TransitRealtime.TripDescriptor.Builder {
                self.startTime = value
                return self
            }
            @discardableResult
            public func clearStartTime() -> TransitRealtime.TripDescriptor.Builder{
                builderResult.hasStartTime = false
                builderResult.startTime = ""
                return self
            }
            /// The scheduled start date of this trip instance.
            /// Must be provided to disambiguate trips that are so late as to collide with
            /// a scheduled trip on a next day. For example, for a train that departs 8:00
            /// and 20:00 every day, and is 12 hours late, there would be two distinct
            /// trips on the same time.
            /// This field can be provided but is not mandatory for schedules in which such
            /// collisions are impossible - for example, a service running on hourly
            /// schedule where a vehicle that is one hour late is not considered to be
            /// related to schedule anymore.
            /// In YYYYMMDD format.
            public var startDate:String {
                get {
                    return builderResult.startDate
                }
                set (value) {
                    builderResult.hasStartDate = true
                    builderResult.startDate = value
                }
            }
            public var hasStartDate:Bool {
                get {
                    return builderResult.hasStartDate
                }
            }
            @discardableResult
            public func setStartDate(_ value:String) -> TransitRealtime.TripDescriptor.Builder {
                self.startDate = value
                return self
            }
            @discardableResult
            public func clearStartDate() -> TransitRealtime.TripDescriptor.Builder{
                builderResult.hasStartDate = false
                builderResult.startDate = ""
                return self
            }
                public var scheduleRelationship:TransitRealtime.TripDescriptor.ScheduleRelationship {
                    get {
                        return builderResult.scheduleRelationship
                    }
                    set (value) {
                        builderResult.hasScheduleRelationship = true
                        builderResult.scheduleRelationship = value
                    }
                }
                public var hasScheduleRelationship:Bool{
                    get {
                        return builderResult.hasScheduleRelationship
                    }
                }
            @discardableResult
                public func setScheduleRelationship(_ value:TransitRealtime.TripDescriptor.ScheduleRelationship) -> TransitRealtime.TripDescriptor.Builder {
                  self.scheduleRelationship = value
                  return self
                }
            @discardableResult
                public func clearScheduleRelationship() -> TransitRealtime.TripDescriptor.Builder {
                   builderResult.hasScheduleRelationship = false
                   builderResult.scheduleRelationship = .scheduled
                   return self
                }
            override public var internalGetResult:ExtendableMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> TransitRealtime.TripDescriptor.Builder {
                builderResult = TransitRealtime.TripDescriptor()
                return self
            }
            override public func clone() throws -> TransitRealtime.TripDescriptor.Builder {
                return try TransitRealtime.TripDescriptor.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> TransitRealtime.TripDescriptor {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> TransitRealtime.TripDescriptor {
                let returnMe:TransitRealtime.TripDescriptor = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:TransitRealtime.TripDescriptor) throws -> TransitRealtime.TripDescriptor.Builder {
                if other == TransitRealtime.TripDescriptor() {
                    return self
                }
                if other.hasTripId {
                    tripId = other.tripId
                }
                if other.hasRouteId {
                    routeId = other.routeId
                }
                if other.hasDirectionId {
                    directionId = other.directionId
                }
                if other.hasStartTime {
                    startTime = other.startTime
                }
                if other.hasStartDate {
                    startDate = other.startDate
                }
                if other.hasScheduleRelationship {
                    scheduleRelationship = other.scheduleRelationship
                }
                try mergeExtensionFields(other: other)
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.TripDescriptor.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripDescriptor.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        tripId = try codedInputStream.readString()

                    case 18:
                        startTime = try codedInputStream.readString()

                    case 26:
                        startDate = try codedInputStream.readString()

                    case 32:
                        let valueIntscheduleRelationship = try codedInputStream.readEnum()
                        if let enumsscheduleRelationship = TransitRealtime.TripDescriptor.ScheduleRelationship(rawValue:valueIntscheduleRelationship){
                            scheduleRelationship = enumsscheduleRelationship
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 4, value:Int64(valueIntscheduleRelationship))
                        }

                    case 42:
                        routeId = try codedInputStream.readString()

                    case 48:
                        directionId = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.TripDescriptor.Builder {
                let resultDecodedBuilder = TransitRealtime.TripDescriptor.Builder()
                if let jsonValueTripId = jsonMap["tripId"] as? String {
                    resultDecodedBuilder.tripId = jsonValueTripId
                }
                if let jsonValueRouteId = jsonMap["routeId"] as? String {
                    resultDecodedBuilder.routeId = jsonValueRouteId
                }
                if let jsonValueDirectionId = jsonMap["directionId"] as? UInt {
                    resultDecodedBuilder.directionId = UInt32(jsonValueDirectionId)
                } else if let jsonValueDirectionId = jsonMap["directionId"] as? String {
                    resultDecodedBuilder.directionId = UInt32(jsonValueDirectionId)!
                }
                if let jsonValueStartTime = jsonMap["startTime"] as? String {
                    resultDecodedBuilder.startTime = jsonValueStartTime
                }
                if let jsonValueStartDate = jsonMap["startDate"] as? String {
                    resultDecodedBuilder.startDate = jsonValueStartDate
                }
                if let jsonValueScheduleRelationship = jsonMap["scheduleRelationship"] as? String {
                    resultDecodedBuilder.scheduleRelationship = try TransitRealtime.TripDescriptor.ScheduleRelationship.fromString(str: jsonValueScheduleRelationship)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> TransitRealtime.TripDescriptor.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try TransitRealtime.TripDescriptor.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// Identification information for the vehicle performing the trip.
    final public class VehicleDescriptor : ExtendableMessage {

        public static func == (lhs: TransitRealtime.VehicleDescriptor, rhs: TransitRealtime.VehicleDescriptor) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
            fieldCheck = fieldCheck && (lhs.hasLabel == rhs.hasLabel) && (!lhs.hasLabel || lhs.label == rhs.label)
            fieldCheck = fieldCheck && (lhs.hasLicensePlate == rhs.hasLicensePlate) && (!lhs.hasLicensePlate || lhs.licensePlate == rhs.licensePlate)
            fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:2000)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// Internal system identification of the vehicle. Should be unique per
        /// vehicle, and can be used for tracking the vehicle as it proceeds through
        /// the system.
        public fileprivate(set) var id:String = ""
        public fileprivate(set) var hasId:Bool = false

        /// User visible label, i.e., something that must be shown to the passenger to
        /// help identify the correct vehicle.
        public fileprivate(set) var label:String = ""
        public fileprivate(set) var hasLabel:Bool = false

        /// The license plate of the vehicle.
        public fileprivate(set) var licensePlate:String = ""
        public fileprivate(set) var hasLicensePlate:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !extensionsAreInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasId {
                try codedOutputStream.writeString(fieldNumber: 1, value:id)
            }
            if hasLabel {
                try codedOutputStream.writeString(fieldNumber: 2, value:label)
            }
            if hasLicensePlate {
                try codedOutputStream.writeString(fieldNumber: 3, value:licensePlate)
            }
            try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:2000)
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasId {
                serialize_size += id.computeStringSize(fieldNumber: 1)
            }
            if hasLabel {
                serialize_size += label.computeStringSize(fieldNumber: 2)
            }
            if hasLicensePlate {
                serialize_size += licensePlate.computeStringSize(fieldNumber: 3)
            }
            serialize_size += extensionsSerializedSize()
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> TransitRealtime.VehicleDescriptor.Builder {
            return TransitRealtime.VehicleDescriptor.classBuilder() as! TransitRealtime.VehicleDescriptor.Builder
        }
        public func getBuilder() -> TransitRealtime.VehicleDescriptor.Builder {
            return classBuilder() as! TransitRealtime.VehicleDescriptor.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.VehicleDescriptor.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.VehicleDescriptor.Builder()
        }
        public func toBuilder() throws -> TransitRealtime.VehicleDescriptor.Builder {
            return try TransitRealtime.VehicleDescriptor.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:TransitRealtime.VehicleDescriptor) throws -> TransitRealtime.VehicleDescriptor.Builder {
            return try TransitRealtime.VehicleDescriptor.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasId {
                jsonMap["id"] = id
            }
            if hasLabel {
                jsonMap["label"] = label
            }
            if hasLicensePlate {
                jsonMap["licensePlate"] = licensePlate
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.VehicleDescriptor {
            return try TransitRealtime.VehicleDescriptor.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> TransitRealtime.VehicleDescriptor {
            return try TransitRealtime.VehicleDescriptor.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasId {
                output += "\(indent) id: \(id) \n"
            }
            if hasLabel {
                output += "\(indent) label: \(label) \n"
            }
            if hasLicensePlate {
                output += "\(indent) licensePlate: \(licensePlate) \n"
            }
            output += try getExtensionDescription(startInclusive:1000, endExclusive:2000, indent:indent)
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasId {
                    hashCode = (hashCode &* 31) &+ id.hashValue
                }
                if hasLabel {
                    hashCode = (hashCode &* 31) &+ label.hashValue
                }
                if hasLicensePlate {
                    hashCode = (hashCode &* 31) &+ licensePlate.hashValue
                }
                hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:2000))
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "TransitRealtime.VehicleDescriptor"
        }
        override public func className() -> String {
            return "TransitRealtime.VehicleDescriptor"
        }
        //Meta information declaration end

        final public class Builder : ExtendableMessageBuilder {
            fileprivate var builderResult:TransitRealtime.VehicleDescriptor = TransitRealtime.VehicleDescriptor()
            public func getMessage() -> TransitRealtime.VehicleDescriptor {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// Internal system identification of the vehicle. Should be unique per
            /// vehicle, and can be used for tracking the vehicle as it proceeds through
            /// the system.
            public var id:String {
                get {
                    return builderResult.id
                }
                set (value) {
                    builderResult.hasId = true
                    builderResult.id = value
                }
            }
            public var hasId:Bool {
                get {
                    return builderResult.hasId
                }
            }
            @discardableResult
            public func setId(_ value:String) -> TransitRealtime.VehicleDescriptor.Builder {
                self.id = value
                return self
            }
            @discardableResult
            public func clearId() -> TransitRealtime.VehicleDescriptor.Builder{
                builderResult.hasId = false
                builderResult.id = ""
                return self
            }
            /// User visible label, i.e., something that must be shown to the passenger to
            /// help identify the correct vehicle.
            public var label:String {
                get {
                    return builderResult.label
                }
                set (value) {
                    builderResult.hasLabel = true
                    builderResult.label = value
                }
            }
            public var hasLabel:Bool {
                get {
                    return builderResult.hasLabel
                }
            }
            @discardableResult
            public func setLabel(_ value:String) -> TransitRealtime.VehicleDescriptor.Builder {
                self.label = value
                return self
            }
            @discardableResult
            public func clearLabel() -> TransitRealtime.VehicleDescriptor.Builder{
                builderResult.hasLabel = false
                builderResult.label = ""
                return self
            }
            /// The license plate of the vehicle.
            public var licensePlate:String {
                get {
                    return builderResult.licensePlate
                }
                set (value) {
                    builderResult.hasLicensePlate = true
                    builderResult.licensePlate = value
                }
            }
            public var hasLicensePlate:Bool {
                get {
                    return builderResult.hasLicensePlate
                }
            }
            @discardableResult
            public func setLicensePlate(_ value:String) -> TransitRealtime.VehicleDescriptor.Builder {
                self.licensePlate = value
                return self
            }
            @discardableResult
            public func clearLicensePlate() -> TransitRealtime.VehicleDescriptor.Builder{
                builderResult.hasLicensePlate = false
                builderResult.licensePlate = ""
                return self
            }
            override public var internalGetResult:ExtendableMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> TransitRealtime.VehicleDescriptor.Builder {
                builderResult = TransitRealtime.VehicleDescriptor()
                return self
            }
            override public func clone() throws -> TransitRealtime.VehicleDescriptor.Builder {
                return try TransitRealtime.VehicleDescriptor.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> TransitRealtime.VehicleDescriptor {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> TransitRealtime.VehicleDescriptor {
                let returnMe:TransitRealtime.VehicleDescriptor = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:TransitRealtime.VehicleDescriptor) throws -> TransitRealtime.VehicleDescriptor.Builder {
                if other == TransitRealtime.VehicleDescriptor() {
                    return self
                }
                if other.hasId {
                    id = other.id
                }
                if other.hasLabel {
                    label = other.label
                }
                if other.hasLicensePlate {
                    licensePlate = other.licensePlate
                }
                try mergeExtensionFields(other: other)
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.VehicleDescriptor.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.VehicleDescriptor.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        id = try codedInputStream.readString()

                    case 18:
                        label = try codedInputStream.readString()

                    case 26:
                        licensePlate = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.VehicleDescriptor.Builder {
                let resultDecodedBuilder = TransitRealtime.VehicleDescriptor.Builder()
                if let jsonValueId = jsonMap["id"] as? String {
                    resultDecodedBuilder.id = jsonValueId
                }
                if let jsonValueLabel = jsonMap["label"] as? String {
                    resultDecodedBuilder.label = jsonValueLabel
                }
                if let jsonValueLicensePlate = jsonMap["licensePlate"] as? String {
                    resultDecodedBuilder.licensePlate = jsonValueLicensePlate
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> TransitRealtime.VehicleDescriptor.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try TransitRealtime.VehicleDescriptor.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// A selector for an entity in a GTFS feed.
    final public class EntitySelector : ExtendableMessage {

        public static func == (lhs: TransitRealtime.EntitySelector, rhs: TransitRealtime.EntitySelector) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasAgencyId == rhs.hasAgencyId) && (!lhs.hasAgencyId || lhs.agencyId == rhs.agencyId)
            fieldCheck = fieldCheck && (lhs.hasRouteId == rhs.hasRouteId) && (!lhs.hasRouteId || lhs.routeId == rhs.routeId)
            fieldCheck = fieldCheck && (lhs.hasRouteType == rhs.hasRouteType) && (!lhs.hasRouteType || lhs.routeType == rhs.routeType)
            fieldCheck = fieldCheck && (lhs.hasTrip == rhs.hasTrip) && (!lhs.hasTrip || lhs.trip == rhs.trip)
            fieldCheck = fieldCheck && (lhs.hasStopId == rhs.hasStopId) && (!lhs.hasStopId || lhs.stopId == rhs.stopId)
            fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:2000)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        /// The values of the fields should correspond to the appropriate fields in the
        /// GTFS feed.
        /// At least one specifier must be given. If several are given, then the
        /// matching has to apply to all the given specifiers.
        public fileprivate(set) var agencyId:String = ""
        public fileprivate(set) var hasAgencyId:Bool = false

        public fileprivate(set) var routeId:String = ""
        public fileprivate(set) var hasRouteId:Bool = false

        /// corresponds to route_type in GTFS.
        public fileprivate(set) var routeType:Int32 = Int32(0)
        public fileprivate(set) var hasRouteType:Bool = false

        public fileprivate(set) var trip:TransitRealtime.TripDescriptor!
        public fileprivate(set) var hasTrip:Bool = false
        public fileprivate(set) var stopId:String = ""
        public fileprivate(set) var hasStopId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if hasTrip {
                if !trip.isInitialized() {
                    return false
                }
            }
            if !extensionsAreInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasAgencyId {
                try codedOutputStream.writeString(fieldNumber: 1, value:agencyId)
            }
            if hasRouteId {
                try codedOutputStream.writeString(fieldNumber: 2, value:routeId)
            }
            if hasRouteType {
                try codedOutputStream.writeInt32(fieldNumber: 3, value:routeType)
            }
            if hasTrip {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:trip)
            }
            if hasStopId {
                try codedOutputStream.writeString(fieldNumber: 5, value:stopId)
            }
            try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:2000)
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasAgencyId {
                serialize_size += agencyId.computeStringSize(fieldNumber: 1)
            }
            if hasRouteId {
                serialize_size += routeId.computeStringSize(fieldNumber: 2)
            }
            if hasRouteType {
                serialize_size += routeType.computeInt32Size(fieldNumber: 3)
            }
            if hasTrip {
                if let varSizetrip = trip?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizetrip
                }
            }
            if hasStopId {
                serialize_size += stopId.computeStringSize(fieldNumber: 5)
            }
            serialize_size += extensionsSerializedSize()
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> TransitRealtime.EntitySelector.Builder {
            return TransitRealtime.EntitySelector.classBuilder() as! TransitRealtime.EntitySelector.Builder
        }
        public func getBuilder() -> TransitRealtime.EntitySelector.Builder {
            return classBuilder() as! TransitRealtime.EntitySelector.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.EntitySelector.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.EntitySelector.Builder()
        }
        public func toBuilder() throws -> TransitRealtime.EntitySelector.Builder {
            return try TransitRealtime.EntitySelector.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:TransitRealtime.EntitySelector) throws -> TransitRealtime.EntitySelector.Builder {
            return try TransitRealtime.EntitySelector.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasAgencyId {
                jsonMap["agencyId"] = agencyId
            }
            if hasRouteId {
                jsonMap["routeId"] = routeId
            }
            if hasRouteType {
                jsonMap["routeType"] = Int(routeType)
            }
            if hasTrip {
                jsonMap["trip"] = try trip.encode()
            }
            if hasStopId {
                jsonMap["stopId"] = stopId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.EntitySelector {
            return try TransitRealtime.EntitySelector.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> TransitRealtime.EntitySelector {
            return try TransitRealtime.EntitySelector.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasAgencyId {
                output += "\(indent) agencyId: \(agencyId) \n"
            }
            if hasRouteId {
                output += "\(indent) routeId: \(routeId) \n"
            }
            if hasRouteType {
                output += "\(indent) routeType: \(routeType) \n"
            }
            if hasTrip {
                output += "\(indent) trip {\n"
                if let outDescTrip = trip {
                    output += try outDescTrip.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasStopId {
                output += "\(indent) stopId: \(stopId) \n"
            }
            output += try getExtensionDescription(startInclusive:1000, endExclusive:2000, indent:indent)
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasAgencyId {
                    hashCode = (hashCode &* 31) &+ agencyId.hashValue
                }
                if hasRouteId {
                    hashCode = (hashCode &* 31) &+ routeId.hashValue
                }
                if hasRouteType {
                    hashCode = (hashCode &* 31) &+ routeType.hashValue
                }
                if hasTrip {
                    if let hashValuetrip = trip?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetrip
                    }
                }
                if hasStopId {
                    hashCode = (hashCode &* 31) &+ stopId.hashValue
                }
                hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:2000))
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "TransitRealtime.EntitySelector"
        }
        override public func className() -> String {
            return "TransitRealtime.EntitySelector"
        }
        //Meta information declaration end

        final public class Builder : ExtendableMessageBuilder {
            fileprivate var builderResult:TransitRealtime.EntitySelector = TransitRealtime.EntitySelector()
            public func getMessage() -> TransitRealtime.EntitySelector {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// The values of the fields should correspond to the appropriate fields in the
            /// GTFS feed.
            /// At least one specifier must be given. If several are given, then the
            /// matching has to apply to all the given specifiers.
            public var agencyId:String {
                get {
                    return builderResult.agencyId
                }
                set (value) {
                    builderResult.hasAgencyId = true
                    builderResult.agencyId = value
                }
            }
            public var hasAgencyId:Bool {
                get {
                    return builderResult.hasAgencyId
                }
            }
            @discardableResult
            public func setAgencyId(_ value:String) -> TransitRealtime.EntitySelector.Builder {
                self.agencyId = value
                return self
            }
            @discardableResult
            public func clearAgencyId() -> TransitRealtime.EntitySelector.Builder{
                builderResult.hasAgencyId = false
                builderResult.agencyId = ""
                return self
            }
            public var routeId:String {
                get {
                    return builderResult.routeId
                }
                set (value) {
                    builderResult.hasRouteId = true
                    builderResult.routeId = value
                }
            }
            public var hasRouteId:Bool {
                get {
                    return builderResult.hasRouteId
                }
            }
            @discardableResult
            public func setRouteId(_ value:String) -> TransitRealtime.EntitySelector.Builder {
                self.routeId = value
                return self
            }
            @discardableResult
            public func clearRouteId() -> TransitRealtime.EntitySelector.Builder{
                builderResult.hasRouteId = false
                builderResult.routeId = ""
                return self
            }
            /// corresponds to route_type in GTFS.
            public var routeType:Int32 {
                get {
                    return builderResult.routeType
                }
                set (value) {
                    builderResult.hasRouteType = true
                    builderResult.routeType = value
                }
            }
            public var hasRouteType:Bool {
                get {
                    return builderResult.hasRouteType
                }
            }
            @discardableResult
            public func setRouteType(_ value:Int32) -> TransitRealtime.EntitySelector.Builder {
                self.routeType = value
                return self
            }
            @discardableResult
            public func clearRouteType() -> TransitRealtime.EntitySelector.Builder{
                builderResult.hasRouteType = false
                builderResult.routeType = Int32(0)
                return self
            }
            public var trip:TransitRealtime.TripDescriptor! {
                get {
                    if tripBuilder_ != nil {
                        builderResult.trip = tripBuilder_.getMessage()
                    }
                    return builderResult.trip
                }
                set (value) {
                    builderResult.hasTrip = true
                    builderResult.trip = value
                }
            }
            public var hasTrip:Bool {
                get {
                    return builderResult.hasTrip
                }
            }
            fileprivate var tripBuilder_:TransitRealtime.TripDescriptor.Builder! {
                didSet {
                    builderResult.hasTrip = true
                }
            }
            public func getTripBuilder() -> TransitRealtime.TripDescriptor.Builder {
                if tripBuilder_ == nil {
                    tripBuilder_ = TransitRealtime.TripDescriptor.Builder()
                    builderResult.trip = tripBuilder_.getMessage()
                    if trip != nil {
                        try! tripBuilder_.mergeFrom(other: trip)
                    }
                }
                return tripBuilder_
            }
            @discardableResult
            public func setTrip(_ value:TransitRealtime.TripDescriptor!) -> TransitRealtime.EntitySelector.Builder {
                self.trip = value
                return self
            }
            @discardableResult
            public func mergeTrip(value:TransitRealtime.TripDescriptor) throws -> TransitRealtime.EntitySelector.Builder {
                if builderResult.hasTrip {
                    builderResult.trip = try TransitRealtime.TripDescriptor.builderWithPrototype(prototype:builderResult.trip).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.trip = value
                }
                builderResult.hasTrip = true
                return self
            }
            @discardableResult
            public func clearTrip() -> TransitRealtime.EntitySelector.Builder {
                tripBuilder_ = nil
                builderResult.hasTrip = false
                builderResult.trip = nil
                return self
            }
            public var stopId:String {
                get {
                    return builderResult.stopId
                }
                set (value) {
                    builderResult.hasStopId = true
                    builderResult.stopId = value
                }
            }
            public var hasStopId:Bool {
                get {
                    return builderResult.hasStopId
                }
            }
            @discardableResult
            public func setStopId(_ value:String) -> TransitRealtime.EntitySelector.Builder {
                self.stopId = value
                return self
            }
            @discardableResult
            public func clearStopId() -> TransitRealtime.EntitySelector.Builder{
                builderResult.hasStopId = false
                builderResult.stopId = ""
                return self
            }
            override public var internalGetResult:ExtendableMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> TransitRealtime.EntitySelector.Builder {
                builderResult = TransitRealtime.EntitySelector()
                return self
            }
            override public func clone() throws -> TransitRealtime.EntitySelector.Builder {
                return try TransitRealtime.EntitySelector.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> TransitRealtime.EntitySelector {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> TransitRealtime.EntitySelector {
                let returnMe:TransitRealtime.EntitySelector = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:TransitRealtime.EntitySelector) throws -> TransitRealtime.EntitySelector.Builder {
                if other == TransitRealtime.EntitySelector() {
                    return self
                }
                if other.hasAgencyId {
                    agencyId = other.agencyId
                }
                if other.hasRouteId {
                    routeId = other.routeId
                }
                if other.hasRouteType {
                    routeType = other.routeType
                }
                if (other.hasTrip) {
                    try mergeTrip(value: other.trip)
                }
                if other.hasStopId {
                    stopId = other.stopId
                }
                try mergeExtensionFields(other: other)
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.EntitySelector.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.EntitySelector.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        agencyId = try codedInputStream.readString()

                    case 18:
                        routeId = try codedInputStream.readString()

                    case 24:
                        routeType = try codedInputStream.readInt32()

                    case 34:
                        let subBuilder:TransitRealtime.TripDescriptor.Builder = TransitRealtime.TripDescriptor.Builder()
                        if hasTrip {
                            try subBuilder.mergeFrom(other: trip)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        trip = subBuilder.buildPartial()

                    case 42:
                        stopId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.EntitySelector.Builder {
                let resultDecodedBuilder = TransitRealtime.EntitySelector.Builder()
                if let jsonValueAgencyId = jsonMap["agencyId"] as? String {
                    resultDecodedBuilder.agencyId = jsonValueAgencyId
                }
                if let jsonValueRouteId = jsonMap["routeId"] as? String {
                    resultDecodedBuilder.routeId = jsonValueRouteId
                }
                if let jsonValueRouteType = jsonMap["routeType"] as? Int {
                    resultDecodedBuilder.routeType = Int32(jsonValueRouteType)
                } else if let jsonValueRouteType = jsonMap["routeType"] as? String {
                    resultDecodedBuilder.routeType = Int32(jsonValueRouteType)!
                }
                if let jsonValueTrip = jsonMap["trip"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.trip = try TransitRealtime.TripDescriptor.Builder.decodeToBuilder(jsonMap:jsonValueTrip).build()

                }
                if let jsonValueStopId = jsonMap["stopId"] as? String {
                    resultDecodedBuilder.stopId = jsonValueStopId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> TransitRealtime.EntitySelector.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try TransitRealtime.EntitySelector.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// An internationalized message containing per-language versions of a snippet of
    /// text or a URL.
    /// One of the strings from a message will be picked up. The resolution proceeds
    /// as follows:
    /// 1. If the UI language matches the language code of a translation,
    ///    the first matching translation is picked.
    /// 2. If a default UI language (e.g., English) matches the language code of a
    ///    translation, the first matching translation is picked.
    /// 3. If some translation has an unspecified language code, that translation is
    ///    picked.
    final public class TranslatedString : ExtendableMessage {

        public static func == (lhs: TransitRealtime.TranslatedString, rhs: TransitRealtime.TranslatedString) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.translation == rhs.translation)
            fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:2000)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }



        //Nested type declaration start

        final public class Translation : ExtendableMessage {

            public static func == (lhs: TransitRealtime.TranslatedString.Translation, rhs: TransitRealtime.TranslatedString.Translation) -> Bool {
                if lhs === rhs {
                    return true
                }
                var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
                fieldCheck = fieldCheck && (lhs.hasText == rhs.hasText) && (!lhs.hasText || lhs.text == rhs.text)
                fieldCheck = fieldCheck && (lhs.hasLanguage == rhs.hasLanguage) && (!lhs.hasLanguage || lhs.language == rhs.language)
                fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(otherMessage: rhs, startInclusive:1000, endExclusive:2000)
                fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
                return fieldCheck
            }

            /// A UTF-8 string containing the message.
            public fileprivate(set) var text:String = ""
            public fileprivate(set) var hasText:Bool = false

            /// BCP-47 language code. Can be omitted if the language is unknown or if
            /// no i18n is done at all for the feed. At most one translation is
            /// allowed to have an unspecified language tag.
            public fileprivate(set) var language:String = ""
            public fileprivate(set) var hasLanguage:Bool = false

            required public init() {
                super.init()
            }
            override public func isInitialized() -> Bool {
                if !hasText {
                    return false
                }
                if !extensionsAreInitialized() {
                    return false
                }
                return true
            }
            override public func writeTo(codedOutputStream: CodedOutputStream) throws {
                if hasText {
                    try codedOutputStream.writeString(fieldNumber: 1, value:text)
                }
                if hasLanguage {
                    try codedOutputStream.writeString(fieldNumber: 2, value:language)
                }
                try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:2000)
                try unknownFields.writeTo(codedOutputStream: codedOutputStream)
            }
            override public func serializedSize() -> Int32 {
                var serialize_size:Int32 = memoizedSerializedSize
                if serialize_size != -1 {
                 return serialize_size
                }

                serialize_size = 0
                if hasText {
                    serialize_size += text.computeStringSize(fieldNumber: 1)
                }
                if hasLanguage {
                    serialize_size += language.computeStringSize(fieldNumber: 2)
                }
                serialize_size += extensionsSerializedSize()
                serialize_size += unknownFields.serializedSize()
                memoizedSerializedSize = serialize_size
                return serialize_size
            }
            public class func getBuilder() -> TransitRealtime.TranslatedString.Translation.Builder {
                return TransitRealtime.TranslatedString.Translation.classBuilder() as! TransitRealtime.TranslatedString.Translation.Builder
            }
            public func getBuilder() -> TransitRealtime.TranslatedString.Translation.Builder {
                return classBuilder() as! TransitRealtime.TranslatedString.Translation.Builder
            }
            override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
                return TransitRealtime.TranslatedString.Translation.Builder()
            }
            override public func classBuilder() -> ProtocolBuffersMessageBuilder {
                return TransitRealtime.TranslatedString.Translation.Builder()
            }
            public func toBuilder() throws -> TransitRealtime.TranslatedString.Translation.Builder {
                return try TransitRealtime.TranslatedString.Translation.builderWithPrototype(prototype:self)
            }
            public class func builderWithPrototype(prototype:TransitRealtime.TranslatedString.Translation) throws -> TransitRealtime.TranslatedString.Translation.Builder {
                return try TransitRealtime.TranslatedString.Translation.Builder().mergeFrom(other:prototype)
            }
            override public func encode() throws -> Dictionary<String,Any> {
                guard isInitialized() else {
                    throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
                }

                var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
                if hasText {
                    jsonMap["text"] = text
                }
                if hasLanguage {
                    jsonMap["language"] = language
                }
                return jsonMap
            }
            override class public func decode(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.TranslatedString.Translation {
                return try TransitRealtime.TranslatedString.Translation.Builder.decodeToBuilder(jsonMap:jsonMap).build()
            }
            override class public func fromJSON(data:Data) throws -> TransitRealtime.TranslatedString.Translation {
                return try TransitRealtime.TranslatedString.Translation.Builder.fromJSONToBuilder(data:data).build()
            }
            override public func getDescription(indent:String) throws -> String {
                var output = ""
                if hasText {
                    output += "\(indent) text: \(text) \n"
                }
                if hasLanguage {
                    output += "\(indent) language: \(language) \n"
                }
                output += try getExtensionDescription(startInclusive:1000, endExclusive:2000, indent:indent)
                output += unknownFields.getDescription(indent: indent)
                return output
            }
            override public var hashValue:Int {
                get {
                    var hashCode:Int = 7
                    if hasText {
                        hashCode = (hashCode &* 31) &+ text.hashValue
                    }
                    if hasLanguage {
                        hashCode = (hashCode &* 31) &+ language.hashValue
                    }
                    hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:2000))
                    hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                    return hashCode
                }
            }


            //Meta information declaration start

            override public class func className() -> String {
                return "TransitRealtime.TranslatedString.Translation"
            }
            override public func className() -> String {
                return "TransitRealtime.TranslatedString.Translation"
            }
            //Meta information declaration end

            final public class Builder : ExtendableMessageBuilder {
                fileprivate var builderResult:TransitRealtime.TranslatedString.Translation = TransitRealtime.TranslatedString.Translation()
                public func getMessage() -> TransitRealtime.TranslatedString.Translation {
                    return builderResult
                }

                required override public init () {
                    super.init()
                }
                /// A UTF-8 string containing the message.
                public var text:String {
                    get {
                        return builderResult.text
                    }
                    set (value) {
                        builderResult.hasText = true
                        builderResult.text = value
                    }
                }
                public var hasText:Bool {
                    get {
                        return builderResult.hasText
                    }
                }
                @discardableResult
                public func setText(_ value:String) -> TransitRealtime.TranslatedString.Translation.Builder {
                    self.text = value
                    return self
                }
                @discardableResult
                public func clearText() -> TransitRealtime.TranslatedString.Translation.Builder{
                    builderResult.hasText = false
                    builderResult.text = ""
                    return self
                }
                /// BCP-47 language code. Can be omitted if the language is unknown or if
                /// no i18n is done at all for the feed. At most one translation is
                /// allowed to have an unspecified language tag.
                public var language:String {
                    get {
                        return builderResult.language
                    }
                    set (value) {
                        builderResult.hasLanguage = true
                        builderResult.language = value
                    }
                }
                public var hasLanguage:Bool {
                    get {
                        return builderResult.hasLanguage
                    }
                }
                @discardableResult
                public func setLanguage(_ value:String) -> TransitRealtime.TranslatedString.Translation.Builder {
                    self.language = value
                    return self
                }
                @discardableResult
                public func clearLanguage() -> TransitRealtime.TranslatedString.Translation.Builder{
                    builderResult.hasLanguage = false
                    builderResult.language = ""
                    return self
                }
                override public var internalGetResult:ExtendableMessage {
                    get {
                        return builderResult
                    }
                }
                @discardableResult
                override public func clear() -> TransitRealtime.TranslatedString.Translation.Builder {
                    builderResult = TransitRealtime.TranslatedString.Translation()
                    return self
                }
                override public func clone() throws -> TransitRealtime.TranslatedString.Translation.Builder {
                    return try TransitRealtime.TranslatedString.Translation.builderWithPrototype(prototype:builderResult)
                }
                override public func build() throws -> TransitRealtime.TranslatedString.Translation {
                    try checkInitialized()
                    return buildPartial()
                }
                public func buildPartial() -> TransitRealtime.TranslatedString.Translation {
                    let returnMe:TransitRealtime.TranslatedString.Translation = builderResult
                    return returnMe
                }
                @discardableResult
                public func mergeFrom(other:TransitRealtime.TranslatedString.Translation) throws -> TransitRealtime.TranslatedString.Translation.Builder {
                    if other == TransitRealtime.TranslatedString.Translation() {
                        return self
                    }
                    if other.hasText {
                        text = other.text
                    }
                    if other.hasLanguage {
                        language = other.language
                    }
                    try mergeExtensionFields(other: other)
                    try merge(unknownField: other.unknownFields)
                    return self
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.TranslatedString.Translation.Builder {
                    return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
                }
                @discardableResult
                override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TranslatedString.Translation.Builder {
                    let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                    while (true) {
                        let protobufTag = try codedInputStream.readTag()
                        switch protobufTag {
                        case 0: 
                            self.unknownFields = try unknownFieldsBuilder.build()
                            return self

                        case 10:
                            text = try codedInputStream.readString()

                        case 18:
                            language = try codedInputStream.readString()

                        default:
                            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                                unknownFields = try unknownFieldsBuilder.build()
                                return self
                            }
                        }
                    }
                }
                class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.TranslatedString.Translation.Builder {
                    let resultDecodedBuilder = TransitRealtime.TranslatedString.Translation.Builder()
                    if let jsonValueText = jsonMap["text"] as? String {
                        resultDecodedBuilder.text = jsonValueText
                    }
                    if let jsonValueLanguage = jsonMap["language"] as? String {
                        resultDecodedBuilder.language = jsonValueLanguage
                    }
                    return resultDecodedBuilder
                }
                override class public func fromJSONToBuilder(data:Data) throws -> TransitRealtime.TranslatedString.Translation.Builder {
                    let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                    guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                      throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    return try TransitRealtime.TranslatedString.Translation.Builder.decodeToBuilder(jsonMap:jsDataCast)
                }
            }

        }

        //Nested type declaration end

        public fileprivate(set) var translation:Array<TransitRealtime.TranslatedString.Translation>  = Array<TransitRealtime.TranslatedString.Translation>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitTranslation:Bool = true
            for oneElementTranslation in translation {
                if !oneElementTranslation.isInitialized() {
                    isInitTranslation = false
                    break 
                }
            }
            if !isInitTranslation {
                return isInitTranslation
            }
            if !extensionsAreInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementTranslation in translation {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementTranslation)
            }
            try writeExtensionsTo(codedOutputStream: codedOutputStream, startInclusive:1000, endExclusive:2000)
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementTranslation in translation {
                serialize_size += oneElementTranslation.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += extensionsSerializedSize()
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> TransitRealtime.TranslatedString.Builder {
            return TransitRealtime.TranslatedString.classBuilder() as! TransitRealtime.TranslatedString.Builder
        }
        public func getBuilder() -> TransitRealtime.TranslatedString.Builder {
            return classBuilder() as! TransitRealtime.TranslatedString.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.TranslatedString.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return TransitRealtime.TranslatedString.Builder()
        }
        public func toBuilder() throws -> TransitRealtime.TranslatedString.Builder {
            return try TransitRealtime.TranslatedString.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:TransitRealtime.TranslatedString) throws -> TransitRealtime.TranslatedString.Builder {
            return try TransitRealtime.TranslatedString.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !translation.isEmpty {
                var jsonArrayTranslation:Array<Dictionary<String,Any>> = []
                for oneValueTranslation in translation {
                    let ecodedMessageTranslation = try oneValueTranslation.encode()
                    jsonArrayTranslation.append(ecodedMessageTranslation)
                }
                jsonMap["translation"] = jsonArrayTranslation
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.TranslatedString {
            return try TransitRealtime.TranslatedString.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> TransitRealtime.TranslatedString {
            return try TransitRealtime.TranslatedString.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var translationElementIndex:Int = 0
            for oneElementTranslation in translation {
                output += "\(indent) translation[\(translationElementIndex)] {\n"
                output += try oneElementTranslation.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                translationElementIndex += 1
            }
            output += try getExtensionDescription(startInclusive:1000, endExclusive:2000, indent:indent)
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementTranslation in translation {
                    hashCode = (hashCode &* 31) &+ oneElementTranslation.hashValue
                }
                hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(startInclusive: 1000, endExclusive:2000))
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "TransitRealtime.TranslatedString"
        }
        override public func className() -> String {
            return "TransitRealtime.TranslatedString"
        }
        //Meta information declaration end

        final public class Builder : ExtendableMessageBuilder {
            fileprivate var builderResult:TransitRealtime.TranslatedString = TransitRealtime.TranslatedString()
            public func getMessage() -> TransitRealtime.TranslatedString {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            /// At least one translation must be provided.
            public var translation:Array<TransitRealtime.TranslatedString.Translation> {
                get {
                    return builderResult.translation
                }
                set (value) {
                    builderResult.translation = value
                }
            }
            @discardableResult
            public func setTranslation(_ value:Array<TransitRealtime.TranslatedString.Translation>) -> TransitRealtime.TranslatedString.Builder {
                self.translation = value
                return self
            }
            @discardableResult
            public func clearTranslation() -> TransitRealtime.TranslatedString.Builder {
                builderResult.translation.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:ExtendableMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> TransitRealtime.TranslatedString.Builder {
                builderResult = TransitRealtime.TranslatedString()
                return self
            }
            override public func clone() throws -> TransitRealtime.TranslatedString.Builder {
                return try TransitRealtime.TranslatedString.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> TransitRealtime.TranslatedString {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> TransitRealtime.TranslatedString {
                let returnMe:TransitRealtime.TranslatedString = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:TransitRealtime.TranslatedString) throws -> TransitRealtime.TranslatedString.Builder {
                if other == TransitRealtime.TranslatedString() {
                    return self
                }
                if !other.translation.isEmpty  {
                     builderResult.translation += other.translation
                }
                try mergeExtensionFields(other: other)
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.TranslatedString.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TranslatedString.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = TransitRealtime.TranslatedString.Translation.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        translation.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> TransitRealtime.TranslatedString.Builder {
                let resultDecodedBuilder = TransitRealtime.TranslatedString.Builder()
                if let jsonValueTranslation = jsonMap["translation"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayTranslation:Array<TransitRealtime.TranslatedString.Translation> = []
                    for oneValueTranslation in jsonValueTranslation {
                        let messageFromStringTranslation = try TransitRealtime.TranslatedString.Translation.Builder.decodeToBuilder(jsonMap:oneValueTranslation).build()

                        jsonArrayTranslation.append(messageFromStringTranslation)
                    }
                    resultDecodedBuilder.translation = jsonArrayTranslation
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> TransitRealtime.TranslatedString.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try TransitRealtime.TranslatedString.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension TransitRealtime.FeedMessage: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<TransitRealtime.FeedMessage> {
        var mergedArray = Array<TransitRealtime.FeedMessage>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> TransitRealtime.FeedMessage? {
        return try TransitRealtime.FeedMessage.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> TransitRealtime.FeedMessage {
        return try TransitRealtime.FeedMessage.Builder().mergeFrom(data: data, extensionRegistry:TransitRealtime.GtfsRealtimeRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedMessage {
        return try TransitRealtime.FeedMessage.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> TransitRealtime.FeedMessage {
        return try TransitRealtime.FeedMessage.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedMessage {
        return try TransitRealtime.FeedMessage.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.FeedMessage {
        return try TransitRealtime.FeedMessage.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedMessage {
        return try TransitRealtime.FeedMessage.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "header": return self.header
        case "entity": return self.entity
        default: return nil
        }
    }
}
extension TransitRealtime.FeedMessage.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "header": return self.header
            case "entity": return self.entity
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "header":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.FeedHeader else {
                    return
                }
                self.header = newSubscriptValue
            case "entity":
                guard let newSubscriptValue = newSubscriptValue as? Array<TransitRealtime.FeedEntity> else {
                    return
                }
                self.entity = newSubscriptValue
            default: return
            }
        }
    }
}
extension TransitRealtime.FeedHeader: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<TransitRealtime.FeedHeader> {
        var mergedArray = Array<TransitRealtime.FeedHeader>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> TransitRealtime.FeedHeader? {
        return try TransitRealtime.FeedHeader.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> TransitRealtime.FeedHeader {
        return try TransitRealtime.FeedHeader.Builder().mergeFrom(data: data, extensionRegistry:TransitRealtime.GtfsRealtimeRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedHeader {
        return try TransitRealtime.FeedHeader.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> TransitRealtime.FeedHeader {
        return try TransitRealtime.FeedHeader.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedHeader {
        return try TransitRealtime.FeedHeader.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.FeedHeader {
        return try TransitRealtime.FeedHeader.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedHeader {
        return try TransitRealtime.FeedHeader.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "gtfsRealtimeVersion": return self.gtfsRealtimeVersion
        case "incrementality": return self.incrementality
        case "timestamp": return self.timestamp
        default: return nil
        }
    }
}
extension TransitRealtime.FeedHeader.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "gtfsRealtimeVersion": return self.gtfsRealtimeVersion
            case "incrementality": return self.incrementality
            case "timestamp": return self.timestamp
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "gtfsRealtimeVersion":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.gtfsRealtimeVersion = newSubscriptValue
            case "incrementality":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.FeedHeader.Incrementality else {
                    return
                }
                self.incrementality = newSubscriptValue
            case "timestamp":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.timestamp = newSubscriptValue
            default: return
            }
        }
    }
}
extension TransitRealtime.FeedEntity: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<TransitRealtime.FeedEntity> {
        var mergedArray = Array<TransitRealtime.FeedEntity>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> TransitRealtime.FeedEntity? {
        return try TransitRealtime.FeedEntity.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> TransitRealtime.FeedEntity {
        return try TransitRealtime.FeedEntity.Builder().mergeFrom(data: data, extensionRegistry:TransitRealtime.GtfsRealtimeRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedEntity {
        return try TransitRealtime.FeedEntity.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> TransitRealtime.FeedEntity {
        return try TransitRealtime.FeedEntity.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedEntity {
        return try TransitRealtime.FeedEntity.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.FeedEntity {
        return try TransitRealtime.FeedEntity.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.FeedEntity {
        return try TransitRealtime.FeedEntity.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "isDeleted": return self.isDeleted
        case "tripUpdate": return self.tripUpdate
        case "vehicle": return self.vehicle
        case "alert": return self.alert
        default: return nil
        }
    }
}
extension TransitRealtime.FeedEntity.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "isDeleted": return self.isDeleted
            case "tripUpdate": return self.tripUpdate
            case "vehicle": return self.vehicle
            case "alert": return self.alert
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.id = newSubscriptValue
            case "isDeleted":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.isDeleted = newSubscriptValue
            case "tripUpdate":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.TripUpdate else {
                    return
                }
                self.tripUpdate = newSubscriptValue
            case "vehicle":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.VehiclePosition else {
                    return
                }
                self.vehicle = newSubscriptValue
            case "alert":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.Alert else {
                    return
                }
                self.alert = newSubscriptValue
            default: return
            }
        }
    }
}
extension TransitRealtime.TripUpdate: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<TransitRealtime.TripUpdate> {
        var mergedArray = Array<TransitRealtime.TripUpdate>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> TransitRealtime.TripUpdate? {
        return try TransitRealtime.TripUpdate.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> TransitRealtime.TripUpdate {
        return try TransitRealtime.TripUpdate.Builder().mergeFrom(data: data, extensionRegistry:TransitRealtime.GtfsRealtimeRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate {
        return try TransitRealtime.TripUpdate.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> TransitRealtime.TripUpdate {
        return try TransitRealtime.TripUpdate.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate {
        return try TransitRealtime.TripUpdate.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.TripUpdate {
        return try TransitRealtime.TripUpdate.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate {
        return try TransitRealtime.TripUpdate.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "trip": return self.trip
        case "vehicle": return self.vehicle
        case "stopTimeUpdate": return self.stopTimeUpdate
        case "timestamp": return self.timestamp
        case "delay": return self.delay
        default: return nil
        }
    }
}
extension TransitRealtime.TripUpdate.StopTimeEvent: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<TransitRealtime.TripUpdate.StopTimeEvent> {
        var mergedArray = Array<TransitRealtime.TripUpdate.StopTimeEvent>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> TransitRealtime.TripUpdate.StopTimeEvent? {
        return try TransitRealtime.TripUpdate.StopTimeEvent.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> TransitRealtime.TripUpdate.StopTimeEvent {
        return try TransitRealtime.TripUpdate.StopTimeEvent.Builder().mergeFrom(data: data, extensionRegistry:TransitRealtime.GtfsRealtimeRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate.StopTimeEvent {
        return try TransitRealtime.TripUpdate.StopTimeEvent.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> TransitRealtime.TripUpdate.StopTimeEvent {
        return try TransitRealtime.TripUpdate.StopTimeEvent.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate.StopTimeEvent {
        return try TransitRealtime.TripUpdate.StopTimeEvent.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.TripUpdate.StopTimeEvent {
        return try TransitRealtime.TripUpdate.StopTimeEvent.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate.StopTimeEvent {
        return try TransitRealtime.TripUpdate.StopTimeEvent.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "delay": return self.delay
        case "time": return self.time
        case "uncertainty": return self.uncertainty
        default: return nil
        }
    }
}
extension TransitRealtime.TripUpdate.StopTimeUpdate: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<TransitRealtime.TripUpdate.StopTimeUpdate> {
        var mergedArray = Array<TransitRealtime.TripUpdate.StopTimeUpdate>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> TransitRealtime.TripUpdate.StopTimeUpdate? {
        return try TransitRealtime.TripUpdate.StopTimeUpdate.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> TransitRealtime.TripUpdate.StopTimeUpdate {
        return try TransitRealtime.TripUpdate.StopTimeUpdate.Builder().mergeFrom(data: data, extensionRegistry:TransitRealtime.GtfsRealtimeRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate.StopTimeUpdate {
        return try TransitRealtime.TripUpdate.StopTimeUpdate.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> TransitRealtime.TripUpdate.StopTimeUpdate {
        return try TransitRealtime.TripUpdate.StopTimeUpdate.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate.StopTimeUpdate {
        return try TransitRealtime.TripUpdate.StopTimeUpdate.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.TripUpdate.StopTimeUpdate {
        return try TransitRealtime.TripUpdate.StopTimeUpdate.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripUpdate.StopTimeUpdate {
        return try TransitRealtime.TripUpdate.StopTimeUpdate.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "stopSequence": return self.stopSequence
        case "stopId": return self.stopId
        case "arrival": return self.arrival
        case "departure": return self.departure
        case "scheduleRelationship": return self.scheduleRelationship
        default: return nil
        }
    }
}
extension TransitRealtime.TripUpdate.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "trip": return self.trip
            case "vehicle": return self.vehicle
            case "stopTimeUpdate": return self.stopTimeUpdate
            case "timestamp": return self.timestamp
            case "delay": return self.delay
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "trip":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.TripDescriptor else {
                    return
                }
                self.trip = newSubscriptValue
            case "vehicle":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.VehicleDescriptor else {
                    return
                }
                self.vehicle = newSubscriptValue
            case "stopTimeUpdate":
                guard let newSubscriptValue = newSubscriptValue as? Array<TransitRealtime.TripUpdate.StopTimeUpdate> else {
                    return
                }
                self.stopTimeUpdate = newSubscriptValue
            case "timestamp":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.timestamp = newSubscriptValue
            case "delay":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.delay = newSubscriptValue
            default: return
            }
        }
    }
}
extension TransitRealtime.TripUpdate.StopTimeEvent.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "delay": return self.delay
            case "time": return self.time
            case "uncertainty": return self.uncertainty
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "delay":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.delay = newSubscriptValue
            case "time":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.time = newSubscriptValue
            case "uncertainty":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.uncertainty = newSubscriptValue
            default: return
            }
        }
    }
}
extension TransitRealtime.TripUpdate.StopTimeUpdate.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "stopSequence": return self.stopSequence
            case "stopId": return self.stopId
            case "arrival": return self.arrival
            case "departure": return self.departure
            case "scheduleRelationship": return self.scheduleRelationship
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "stopSequence":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.stopSequence = newSubscriptValue
            case "stopId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.stopId = newSubscriptValue
            case "arrival":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.TripUpdate.StopTimeEvent else {
                    return
                }
                self.arrival = newSubscriptValue
            case "departure":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.TripUpdate.StopTimeEvent else {
                    return
                }
                self.departure = newSubscriptValue
            case "scheduleRelationship":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship else {
                    return
                }
                self.scheduleRelationship = newSubscriptValue
            default: return
            }
        }
    }
}
extension TransitRealtime.VehiclePosition: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<TransitRealtime.VehiclePosition> {
        var mergedArray = Array<TransitRealtime.VehiclePosition>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> TransitRealtime.VehiclePosition? {
        return try TransitRealtime.VehiclePosition.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> TransitRealtime.VehiclePosition {
        return try TransitRealtime.VehiclePosition.Builder().mergeFrom(data: data, extensionRegistry:TransitRealtime.GtfsRealtimeRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.VehiclePosition {
        return try TransitRealtime.VehiclePosition.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> TransitRealtime.VehiclePosition {
        return try TransitRealtime.VehiclePosition.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.VehiclePosition {
        return try TransitRealtime.VehiclePosition.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.VehiclePosition {
        return try TransitRealtime.VehiclePosition.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.VehiclePosition {
        return try TransitRealtime.VehiclePosition.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "trip": return self.trip
        case "vehicle": return self.vehicle
        case "position": return self.position
        case "currentStopSequence": return self.currentStopSequence
        case "stopId": return self.stopId
        case "currentStatus": return self.currentStatus
        case "timestamp": return self.timestamp
        case "congestionLevel": return self.congestionLevel
        case "occupancyStatus": return self.occupancyStatus
        default: return nil
        }
    }
}
extension TransitRealtime.VehiclePosition.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "trip": return self.trip
            case "vehicle": return self.vehicle
            case "position": return self.position
            case "currentStopSequence": return self.currentStopSequence
            case "stopId": return self.stopId
            case "currentStatus": return self.currentStatus
            case "timestamp": return self.timestamp
            case "congestionLevel": return self.congestionLevel
            case "occupancyStatus": return self.occupancyStatus
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "trip":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.TripDescriptor else {
                    return
                }
                self.trip = newSubscriptValue
            case "vehicle":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.VehicleDescriptor else {
                    return
                }
                self.vehicle = newSubscriptValue
            case "position":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.Position else {
                    return
                }
                self.position = newSubscriptValue
            case "currentStopSequence":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.currentStopSequence = newSubscriptValue
            case "stopId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.stopId = newSubscriptValue
            case "currentStatus":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.VehiclePosition.VehicleStopStatus else {
                    return
                }
                self.currentStatus = newSubscriptValue
            case "timestamp":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.timestamp = newSubscriptValue
            case "congestionLevel":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.VehiclePosition.CongestionLevel else {
                    return
                }
                self.congestionLevel = newSubscriptValue
            case "occupancyStatus":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.VehiclePosition.OccupancyStatus else {
                    return
                }
                self.occupancyStatus = newSubscriptValue
            default: return
            }
        }
    }
}
extension TransitRealtime.Alert: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<TransitRealtime.Alert> {
        var mergedArray = Array<TransitRealtime.Alert>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> TransitRealtime.Alert? {
        return try TransitRealtime.Alert.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> TransitRealtime.Alert {
        return try TransitRealtime.Alert.Builder().mergeFrom(data: data, extensionRegistry:TransitRealtime.GtfsRealtimeRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.Alert {
        return try TransitRealtime.Alert.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> TransitRealtime.Alert {
        return try TransitRealtime.Alert.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.Alert {
        return try TransitRealtime.Alert.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.Alert {
        return try TransitRealtime.Alert.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.Alert {
        return try TransitRealtime.Alert.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "activePeriod": return self.activePeriod
        case "informedEntity": return self.informedEntity
        case "cause": return self.cause
        case "effect": return self.effect
        case "url": return self.url
        case "headerText": return self.headerText
        case "descriptionText": return self.descriptionText
        default: return nil
        }
    }
}
extension TransitRealtime.Alert.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "activePeriod": return self.activePeriod
            case "informedEntity": return self.informedEntity
            case "cause": return self.cause
            case "effect": return self.effect
            case "url": return self.url
            case "headerText": return self.headerText
            case "descriptionText": return self.descriptionText
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "activePeriod":
                guard let newSubscriptValue = newSubscriptValue as? Array<TransitRealtime.TimeRange> else {
                    return
                }
                self.activePeriod = newSubscriptValue
            case "informedEntity":
                guard let newSubscriptValue = newSubscriptValue as? Array<TransitRealtime.EntitySelector> else {
                    return
                }
                self.informedEntity = newSubscriptValue
            case "cause":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.Alert.Cause else {
                    return
                }
                self.cause = newSubscriptValue
            case "effect":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.Alert.Effect else {
                    return
                }
                self.effect = newSubscriptValue
            case "url":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.TranslatedString else {
                    return
                }
                self.url = newSubscriptValue
            case "headerText":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.TranslatedString else {
                    return
                }
                self.headerText = newSubscriptValue
            case "descriptionText":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.TranslatedString else {
                    return
                }
                self.descriptionText = newSubscriptValue
            default: return
            }
        }
    }
}
extension TransitRealtime.TimeRange: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<TransitRealtime.TimeRange> {
        var mergedArray = Array<TransitRealtime.TimeRange>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> TransitRealtime.TimeRange? {
        return try TransitRealtime.TimeRange.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> TransitRealtime.TimeRange {
        return try TransitRealtime.TimeRange.Builder().mergeFrom(data: data, extensionRegistry:TransitRealtime.GtfsRealtimeRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TimeRange {
        return try TransitRealtime.TimeRange.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> TransitRealtime.TimeRange {
        return try TransitRealtime.TimeRange.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TimeRange {
        return try TransitRealtime.TimeRange.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.TimeRange {
        return try TransitRealtime.TimeRange.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TimeRange {
        return try TransitRealtime.TimeRange.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "start": return self.start
        case "end": return self.end
        default: return nil
        }
    }
}
extension TransitRealtime.TimeRange.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "start": return self.start
            case "end": return self.end
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "start":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.start = newSubscriptValue
            case "end":
                guard let newSubscriptValue = newSubscriptValue as? UInt64 else {
                    return
                }
                self.end = newSubscriptValue
            default: return
            }
        }
    }
}
extension TransitRealtime.Position: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<TransitRealtime.Position> {
        var mergedArray = Array<TransitRealtime.Position>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> TransitRealtime.Position? {
        return try TransitRealtime.Position.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> TransitRealtime.Position {
        return try TransitRealtime.Position.Builder().mergeFrom(data: data, extensionRegistry:TransitRealtime.GtfsRealtimeRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.Position {
        return try TransitRealtime.Position.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> TransitRealtime.Position {
        return try TransitRealtime.Position.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.Position {
        return try TransitRealtime.Position.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.Position {
        return try TransitRealtime.Position.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.Position {
        return try TransitRealtime.Position.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "latitude": return self.latitude
        case "longitude": return self.longitude
        case "bearing": return self.bearing
        case "odometer": return self.odometer
        case "speed": return self.speed
        default: return nil
        }
    }
}
extension TransitRealtime.Position.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "latitude": return self.latitude
            case "longitude": return self.longitude
            case "bearing": return self.bearing
            case "odometer": return self.odometer
            case "speed": return self.speed
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "latitude":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.latitude = newSubscriptValue
            case "longitude":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.longitude = newSubscriptValue
            case "bearing":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.bearing = newSubscriptValue
            case "odometer":
                guard let newSubscriptValue = newSubscriptValue as? Double else {
                    return
                }
                self.odometer = newSubscriptValue
            case "speed":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.speed = newSubscriptValue
            default: return
            }
        }
    }
}
extension TransitRealtime.TripDescriptor: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<TransitRealtime.TripDescriptor> {
        var mergedArray = Array<TransitRealtime.TripDescriptor>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> TransitRealtime.TripDescriptor? {
        return try TransitRealtime.TripDescriptor.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> TransitRealtime.TripDescriptor {
        return try TransitRealtime.TripDescriptor.Builder().mergeFrom(data: data, extensionRegistry:TransitRealtime.GtfsRealtimeRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripDescriptor {
        return try TransitRealtime.TripDescriptor.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> TransitRealtime.TripDescriptor {
        return try TransitRealtime.TripDescriptor.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripDescriptor {
        return try TransitRealtime.TripDescriptor.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.TripDescriptor {
        return try TransitRealtime.TripDescriptor.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TripDescriptor {
        return try TransitRealtime.TripDescriptor.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "tripId": return self.tripId
        case "routeId": return self.routeId
        case "directionId": return self.directionId
        case "startTime": return self.startTime
        case "startDate": return self.startDate
        case "scheduleRelationship": return self.scheduleRelationship
        default: return nil
        }
    }
}
extension TransitRealtime.TripDescriptor.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "tripId": return self.tripId
            case "routeId": return self.routeId
            case "directionId": return self.directionId
            case "startTime": return self.startTime
            case "startDate": return self.startDate
            case "scheduleRelationship": return self.scheduleRelationship
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "tripId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.tripId = newSubscriptValue
            case "routeId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.routeId = newSubscriptValue
            case "directionId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.directionId = newSubscriptValue
            case "startTime":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.startTime = newSubscriptValue
            case "startDate":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.startDate = newSubscriptValue
            case "scheduleRelationship":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.TripDescriptor.ScheduleRelationship else {
                    return
                }
                self.scheduleRelationship = newSubscriptValue
            default: return
            }
        }
    }
}
extension TransitRealtime.VehicleDescriptor: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<TransitRealtime.VehicleDescriptor> {
        var mergedArray = Array<TransitRealtime.VehicleDescriptor>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> TransitRealtime.VehicleDescriptor? {
        return try TransitRealtime.VehicleDescriptor.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> TransitRealtime.VehicleDescriptor {
        return try TransitRealtime.VehicleDescriptor.Builder().mergeFrom(data: data, extensionRegistry:TransitRealtime.GtfsRealtimeRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.VehicleDescriptor {
        return try TransitRealtime.VehicleDescriptor.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> TransitRealtime.VehicleDescriptor {
        return try TransitRealtime.VehicleDescriptor.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.VehicleDescriptor {
        return try TransitRealtime.VehicleDescriptor.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.VehicleDescriptor {
        return try TransitRealtime.VehicleDescriptor.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.VehicleDescriptor {
        return try TransitRealtime.VehicleDescriptor.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "label": return self.label
        case "licensePlate": return self.licensePlate
        default: return nil
        }
    }
}
extension TransitRealtime.VehicleDescriptor.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "label": return self.label
            case "licensePlate": return self.licensePlate
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.id = newSubscriptValue
            case "label":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.label = newSubscriptValue
            case "licensePlate":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.licensePlate = newSubscriptValue
            default: return
            }
        }
    }
}
extension TransitRealtime.EntitySelector: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<TransitRealtime.EntitySelector> {
        var mergedArray = Array<TransitRealtime.EntitySelector>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> TransitRealtime.EntitySelector? {
        return try TransitRealtime.EntitySelector.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> TransitRealtime.EntitySelector {
        return try TransitRealtime.EntitySelector.Builder().mergeFrom(data: data, extensionRegistry:TransitRealtime.GtfsRealtimeRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.EntitySelector {
        return try TransitRealtime.EntitySelector.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> TransitRealtime.EntitySelector {
        return try TransitRealtime.EntitySelector.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.EntitySelector {
        return try TransitRealtime.EntitySelector.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.EntitySelector {
        return try TransitRealtime.EntitySelector.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.EntitySelector {
        return try TransitRealtime.EntitySelector.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "agencyId": return self.agencyId
        case "routeId": return self.routeId
        case "routeType": return self.routeType
        case "trip": return self.trip
        case "stopId": return self.stopId
        default: return nil
        }
    }
}
extension TransitRealtime.EntitySelector.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "agencyId": return self.agencyId
            case "routeId": return self.routeId
            case "routeType": return self.routeType
            case "trip": return self.trip
            case "stopId": return self.stopId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "agencyId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.agencyId = newSubscriptValue
            case "routeId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.routeId = newSubscriptValue
            case "routeType":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.routeType = newSubscriptValue
            case "trip":
                guard let newSubscriptValue = newSubscriptValue as? TransitRealtime.TripDescriptor else {
                    return
                }
                self.trip = newSubscriptValue
            case "stopId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.stopId = newSubscriptValue
            default: return
            }
        }
    }
}
extension TransitRealtime.TranslatedString: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<TransitRealtime.TranslatedString> {
        var mergedArray = Array<TransitRealtime.TranslatedString>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> TransitRealtime.TranslatedString? {
        return try TransitRealtime.TranslatedString.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> TransitRealtime.TranslatedString {
        return try TransitRealtime.TranslatedString.Builder().mergeFrom(data: data, extensionRegistry:TransitRealtime.GtfsRealtimeRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TranslatedString {
        return try TransitRealtime.TranslatedString.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> TransitRealtime.TranslatedString {
        return try TransitRealtime.TranslatedString.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TranslatedString {
        return try TransitRealtime.TranslatedString.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.TranslatedString {
        return try TransitRealtime.TranslatedString.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TranslatedString {
        return try TransitRealtime.TranslatedString.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "translation": return self.translation
        default: return nil
        }
    }
}
extension TransitRealtime.TranslatedString.Translation: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<TransitRealtime.TranslatedString.Translation> {
        var mergedArray = Array<TransitRealtime.TranslatedString.Translation>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> TransitRealtime.TranslatedString.Translation? {
        return try TransitRealtime.TranslatedString.Translation.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> TransitRealtime.TranslatedString.Translation {
        return try TransitRealtime.TranslatedString.Translation.Builder().mergeFrom(data: data, extensionRegistry:TransitRealtime.GtfsRealtimeRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TranslatedString.Translation {
        return try TransitRealtime.TranslatedString.Translation.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> TransitRealtime.TranslatedString.Translation {
        return try TransitRealtime.TranslatedString.Translation.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TranslatedString.Translation {
        return try TransitRealtime.TranslatedString.Translation.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> TransitRealtime.TranslatedString.Translation {
        return try TransitRealtime.TranslatedString.Translation.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> TransitRealtime.TranslatedString.Translation {
        return try TransitRealtime.TranslatedString.Translation.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "text": return self.text
        case "language": return self.language
        default: return nil
        }
    }
}
extension TransitRealtime.TranslatedString.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "translation": return self.translation
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "translation":
                guard let newSubscriptValue = newSubscriptValue as? Array<TransitRealtime.TranslatedString.Translation> else {
                    return
                }
                self.translation = newSubscriptValue
            default: return
            }
        }
    }
}
extension TransitRealtime.TranslatedString.Translation.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "text": return self.text
            case "language": return self.language
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "text":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.text = newSubscriptValue
            case "language":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.language = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
